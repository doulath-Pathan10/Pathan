import React from 'react';
import { render, screen, act, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import store from './utils/store/store';

// Mock child components
jest.mock('./router/main', () => () => <div data-testid="main-component">Main Component</div>);
jest.mock('./shared/components/model/model', () => ({ name, handlebuttonClick }: any) => (
  <div data-testid="error-model">
    Error Model: {name}
    <button onClick={handlebuttonClick}>Dismiss</button>
  </div>
));
jest.mock('./shared/components/spinner/spinner', () => () => <div data-testid="spinner">Spinner Component</div>);
jest.mock('./shared/components/model/dynamic-model', () => ({ errorList }: any) => (
  <div data-testid="dynamic-model">
    DynamicModel: {errorList.length > 0 ? 'has-errors' : 'no-errors'}
  </div>
));
jest.mock('./shared/components/model/idle-time-out', () => ({ handlePopUpClick }: any) => (
  <div data-testid="idle-timeout-modal">
    IdleTimeOutModel Component
    <button onClick={handlePopUpClick}>Close</button>
  </div>
));

// Mock activity detector with more control
let activityDetectorCallbacks: any = {};
jest.mock('react-activity-detector', () => ({
  __esModule: true,
  default: ({ onIdle, onActive }: any) => {
    React.useEffect(() => {
      activityDetectorCallbacks = { onIdle, onActive };
      return () => {
        activityDetectorCallbacks = {};
      };
    }, [onIdle, onActive]);
    return null;
  },
}));

// Mock track events
const mockTriggerAdobeEvent = jest.fn();
jest.mock('./services/track-events', () => ({
  triggerAdobeEvent: (...args: any[]) => mockTriggerAdobeEvent(...args),
}));

describe('App Component', () => {
  const renderApp = (state = {}) => {
    const mockStore = {
      ...store,
      getState: () => ({
        loader: { isFetching: { isFetching: false } },
        error: { errors: [], exceptionList: [] },
        ...state,
      }),
      dispatch: jest.fn(),
      subscribe: jest.fn(),
    };

    return render(
      <Provider store={mockStore}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
    activityDetectorCallbacks = {};
  });

  it('renders without crashing', () => {
    renderApp();
    expect(screen.getByTestId('main-component')).toBeInTheDocument();
  });

  it('displays spinner when loader is active', () => {
    renderApp({
      loader: { isFetching: { isFetching: true } },
    });
    expect(screen.getByTestId('spinner')).toBeInTheDocument();
  });

  it('does not display spinner when loader is inactive', () => {
    renderApp({
      loader: { isFetching: { isFetching: false } },
    });
    expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
  });

  it('displays error model when errors exist', () => {
    renderApp({
      error: { errors: ['Test error'], exceptionList: [] },
    });
    expect(screen.getByTestId('error-model')).toBeInTheDocument();
    expect(screen.getByText('Error Model: globalError')).toBeInTheDocument();
  });

  it('handles error model dismissal', () => {
    renderApp({
      error: { errors: ['Test error'], exceptionList: [] },
    });
    fireEvent.click(screen.getByText('Dismiss'));
    // Add assertion for whatever should happen when dismissed
  });

  it('displays dynamic model when exceptionList exists', () => {
    renderApp({
      error: { errors: [], exceptionList: [{ error_header: 'Test header' }] },
    });
    expect(screen.getByTestId('dynamic-model')).toBeInTheDocument();
    expect(screen.getByText('DynamicModel: has-errors')).toBeInTheDocument();
  });

  it('does not display dynamic model when no exceptions exist', () => {
    renderApp({
      error: { errors: [], exceptionList: [] },
    });
    expect(screen.queryByTestId('dynamic-model')).not.toBeInTheDocument();
  });

  it('shows idle timeout modal when user becomes idle', () => {
    renderApp();
    act(() => {
      activityDetectorCallbacks.onIdle();
    });
    expect(screen.getByTestId('idle-timeout-modal')).toBeInTheDocument();
  });

  it('does not show idle modal when loader is active', () => {
    renderApp({
      loader: { isFetching: { isFetching: true } },
    });
    act(() => {
      activityDetectorCallbacks.onIdle();
    });
    expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
  });

  it('closes idle timeout modal when handlePopUpClick is called', () => {
    renderApp();
    act(() => {
      activityDetectorCallbacks.onIdle();
    });
    fireEvent.click(screen.getByText('Close'));
    expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
  });

  it('triggers activity detector callbacks correctly', () => {
    renderApp();
    expect(activityDetectorCallbacks.onIdle).toBeDefined();
    expect(activityDetectorCallbacks.onActive).toBeDefined();
  });

  it('prevents right click context menu', () => {
    const mockPreventDefault = jest.fn();
    renderApp();
    fireEvent.contextMenu(screen.getByTestId('main-component'), {
      preventDefault: mockPreventDefault,
    });
    expect(mockPreventDefault).toHaveBeenCalled();
  });

  it('triggers adobe events for errors', () => {
    renderApp({
      error: {
        errors: ['Test error'],
        exceptionList: [{ error_header: 'Test header' }],
      },
    });
    expect(mockTriggerAdobeEvent).toHaveBeenCalledWith('formError');
  });

  it('triggers formAbandonment event on unload', () => {
    renderApp();
    fireEvent.unload(window);
    expect(mockTriggerAdobeEvent).toHaveBeenCalledWith(
      'formAbandonment',
      'BrowserClose'
    );
  });

  it('cleans up event listeners on unmount', () => {
    const removeEventListenerSpy = jest.spyOn(window, 'removeEventListener');
    const { unmount } = renderApp();
    unmount();
    expect(removeEventListenerSpy).toHaveBeenCalledWith(
      'contextmenu',
      expect.any(Function)
    );
    expect(removeEventListenerSpy).toHaveBeenCalledWith(
      'unload',
      expect.any(Function)
    );
    removeEventListenerSpy.mockRestore();
  });
});
