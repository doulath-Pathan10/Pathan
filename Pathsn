// apiService.test.js
import axios from 'axios';
import {
  getProductInfo,
  getProductMetaData,
  initiateRTOBJourney,
  dispatchError,
  dispatchLoader,
  getLovData,
  preserveRequest,
  postRequest,
  formConfig,
  authorize,
  getOfferData,
  rateRequest,
  documentSubmit,
  signatureSubmit,
  defaultError,
  getToken,
  redirectingToIbanking
} from './apiService';
import { store } from '../utils/store/store';

// Mock axios and other dependencies
jest.mock('axios');
jest.mock('../utils/store/store', () => ({
  store: {
    dispatch: jest.fn(),
    getState: jest.fn()
  }
}));

// Mock environment variables
process.env = {
  REACT_APP_RTOB_BASE_URL: 'https://api.example.com',
  REACT_APP_PRODUCT_INFO_URL: 'https://api.example.com/products',
  REACT_APP_RTOB_APPLICATION_END_POINT: '/applications/',
  REACT_APP_RTOB_MYINFO_AUTHORIZE: '/myinfo-authorize',
  REACT_APP_RTOB_MANUAL_AUTHORIZE: '/manual-authorize',
  REACT_APP_RTOB_FORMCONFIG: '/form-config',
  REACT_APP_RTOB_SAVE_END_POINT: '/preserve',
  REACT_APP_RTOB_CREATE_END_POINT: '/create',
  REACT_APP_RTOB_BASIC_END_POINT: '/basic',
  REACT_APP_RTOB_APPLY_END_POINT: '/apply',
  REACT_APP_RTOB_OFFER_END_POINT: '/offer',
  REACT_APP_RTOB_CONFIRM_END_POINT: '/confirm',
  REACT_APP_RTOB_AIP_END_POINT: '/aip',
  REACT_APP_RTOB_RTIM_END_POINT: '/rtim',
  REACT_APP_DOCUMENT_ACKNOWLEDGE: '/acknowledge',
  REACT_APP_DOCUMENT_UPLOAD: '/upload',
  REACT_APP_IBANKING_URL: 'https://ibanking.example.com',
  REACT_APP_AUTHORIZE_TKN: 'https://api.example.com/authorize-keys',
  REACT_APP_MYINFO_TKN: 'https://api.example.com/myinfo-keys'
};

// Mock URL utility functions
jest.mock('../utils/common/change.utils', () => ({
  getUrl: {
    getParameterByName: jest.fn(),
    getChannelRefNo: jest.fn(),
    getJourneyType: jest.fn(),
    getMyInfo: jest.fn(),
    getProductDetails: jest.fn(),
    getProductInfo: jest.fn(),
    getAggregatorStatus: jest.fn(),
    getChangeUpdate: jest.fn()
  },
  authenticateType: jest.fn(),
  getTokenChno: jest.fn(),
  keyToken: jest.fn()
}));

// Mock other utility functions
jest.mock('./payload', () => ({
  generatePayload: {
    createPayload: jest.fn(),
    formConfigPayload: jest.fn(),
    getCardActivationPayload: jest.fn()
  }
}));

// Mock other services
jest.mock('./submit-service', () => ({
  generateUUID: 'mock-uuid'
}));

// Mock document upload utils
jest.mock('../shared/components/document-upload/document-upload.utils', () => ({
  getAckMetaData: jest.fn()
}));
describe('getProductInfo', () => {
  const mockDispatch = jest.fn();
  const productInfoResponse = [
    { product_type: 'CC', product_category: 'Credit Card', campaign: null },
    { product_type: 'PL', product_category: 'Personal Loan', campaign: null }
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    localStorage.clear();
  });

  it('should dispatch product details for single product', async () => {
    const products = 'CC';
    await getProductInfo(products, productInfoResponse)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'urlParam/productDetails',
        payload: expect.arrayContaining([
          expect.objectContaining({ product_type: 'CC' })
        ])
      })
    );
    expect(localStorage.setItem).toHaveBeenCalledWith(
      'products',
      JSON.stringify([{ product_type: 'CC', product_category: 'Credit Card', campaign: null }])
    );
  });

  it('should dispatch product details for multiple products', async () => {
    const products = 'CC,PL';
    await getProductInfo(products, productInfoResponse)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'urlParam/productDetails',
        payload: expect.arrayContaining([
          expect.objectContaining({ product_type: 'CC' }),
          expect.objectContaining({ product_type: 'PL' })
        ])
      })
    );
  });

  it('should dispatch error when no products found', async () => {
    const products = 'INVALID';
    await getProductInfo(products, productInfoResponse)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'error/getError',
        payload: expect.objectContaining({
          statusCode: 'error',
          statusText: 'no response'
        })
      })
    );
  });

  it('should set campaign when provided', async () => {
    const products = 'CC';
    const campaign = 'SUMMER2023';
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockImplementation((param) => param === 'campaign' ? campaign : null);

    await getProductInfo(products, productInfoResponse)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'urlParam/productDetails',
        payload: expect.arrayContaining([
          expect.objectContaining({ product_type: 'CC', campaign: 'SUMMER2023' })
        ])
      })
    );
  });
});
describe('getProductMetaData', () => {
  const mockDispatch = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    axios.get.mockResolvedValue({
      data: {
        products: [
          { product_type: 'CC', product_category: 'Credit Card' },
          { product_type: 'PL', product_category: 'Personal Loan' }
        ]
      }
    });
  });

  it('should fetch product metadata and dispatch product info', async () => {
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockImplementation((param) => param === 'products' ? 'CC' : null);

    await getProductMetaData(null)(mockDispatch);

    expect(axios.get).toHaveBeenCalledWith(process.env.REACT_APP_PRODUCT_INFO_URL);
    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function)); // getProductInfo
  });

  it('should handle API errors', async () => {
    axios.get.mockRejectedValue(new Error('Network error'));

    await getProductMetaData(null)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'error/getError',
        payload: expect.any(Object)
      })
    );
  });

  it('should use provided product_type when available', async () => {
    await getProductMetaData('PL')(mockDispatch);

    expect(axios.get).toHaveBeenCalled();
    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function));
  });
});
describe('dispatchError', () => {
  const mockDispatch = jest.fn();

  it('should dispatch error with response status', () => {
    const error = {
      response: {
        status: 404,
        statusText: 'Not Found'
      }
    };

    dispatchError(error)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'loader/getState',
      payload: { isFetching: false }
    });
    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'error/getError',
      payload: {
        statusCode: 404,
        statusText: 'Not Found'
      }
    });
  });

  it('should dispatch default error when no response', () => {
    const error = {};

    dispatchError(error)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'error/getError',
      payload: {
        statusCode: 'error',
        statusText: 'no response'
      }
    });
  });
});
describe('dispatchLoader', () => {
  const mockDispatch = jest.fn();

  it('should dispatch loader true', () => {
    dispatchLoader(true)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'loader/getState',
      payload: { isFetching: true }
    });
  });

  it('should dispatch loader false', () => {
    dispatchLoader(false)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'loader/getState',
      payload: { isFetching: false }
    });
  });
});
describe('getLovData', () => {
  const mockDispatch = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    axios.get.mockResolvedValue({ data: ['Option1', 'Option2'] });
  });

  it('should fetch LOV data without search key', async () => {
    await getLovData('nationality')(mockDispatch);

    expect(axios.get).toHaveBeenCalledWith(
      'https://api.example.com/lovrefnationalityformtype=gb'
    );
    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'lov/getLovData',
      payload: {
        label: 'nationality',
        value: ['Option1', 'Option2']
      }
    });
  });

  it('should fetch LOV data with search key', async () => {
    await getLovData('nationality', 'sing')(mockDispatch);

    expect(axios.get).toHaveBeenCalledWith(
      'https://api.example.com/lovrefnationalityformtype=gb&size=25&q=sing'
    );
  });

  it('should handle API errors', async () => {
    axios.get.mockRejectedValue(new Error('Network error'));

    await getLovData('nationality')(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function)); // dispatchError
  });

  it('should handle nationality_add specially', async () => {
    axios.get.mockResolvedValue({ data: ['SG', 'US', 'UK'] });
    
    await getLovData('nationality_add')(mockDispatch);
    
    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'lov/getLovData',
      payload: {
        label: 'nationality_add',
        value: ['US', 'UK'] // First element removed
      }
    });
  });
});
describe('authorize', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    axios.post.mockResolvedValue({
      status: 200,
      data: { channelRefNo: '12345' }
    });
  });

  it('should make authorize request for myinfo flow', async () => {
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockReturnValue(null);
    
    const result = await authorize('myinfo')(jest.fn());

    expect(axios.post).toHaveBeenCalledWith(
      'https://api.example.com/applications/mock-uuid/myinfo-authorize',
      expect.objectContaining({
        products: expect.any(Array),
        myinfo: expect.any(Object)
      })
    );
    expect(result).toEqual({ channelRefNo: '12345' });
  });

  it('should include aggregator data when available', async () => {
    require('../utils/common/change.utils').getUrl.getAggregatorStatus
      .mockReturnValue(true);
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockImplementation((param) => {
        if (param === 'aggregator_code') return 'AGG01';
        if (param === 'aggregator_type') return 'TYPE1';
        return null;
      });

    await authorize('myinfo')(jest.fn());

    expect(axios.post).toHaveBeenCalledWith(
      expect.any(String),
      expect.objectContaining({
        application: expect.objectContaining({
          ext_source: 'AGG01',
          ext_source_type: 'TYPE1'
        })
      })
    );
  });

  it('should handle errors', async () => {
    axios.post.mockRejectedValue(new Error('Network error'));

    await expect(authorize('myinfo')(jest.fn())).rejects.toThrow('Network error');
  });
});
describe('documentSubmit', () => {
  const mockApplicationRefNo = 'APP123';
  const mockChannelRef = 'CH123';
  const mockDocumentStore = {
    finalDocumentList: [
      { docId: 'DOC1', documentStatus: 'Accepted' },
      { docId: 'DOC2', documentStatus: 'Accepted' }
    ],
    optionList: {
      optionsSelected: ['OPT1', 'OPT2']
    }
  };

  beforeEach(() => {
    jest.clearAllMocks();
    axios.request.mockResolvedValue({ status: 200, data: {} });
  });

  it('should submit documents successfully', async () => {
    const result = await documentSubmit(
      mockApplicationRefNo,
      mockChannelRef,
      mockDocumentStore
    );

    expect(axios.request).toHaveBeenCalledWith({
      method: 'POST',
      url: 'https://api.example.com/applications/CH123/acknowledge',
      data: {
        applicationRefNo: 'APP123',
        documents: mockDocumentStore.finalDocumentList,
        options: ['OPT1', 'OPT2']
      },
      headers: expect.any(Object)
    });
    expect(result).resolves.toBeTruthy();
  });

  it('should include psdu flag for upload auth', async () => {
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockReturnValue('upload');

    await documentSubmit(mockApplicationRefNo, mockChannelRef, mockDocumentStore);

    expect(axios.request).toHaveBeenCalledWith(
      expect.objectContaining({
        data: expect.objectContaining({
          psdu: 'Y'
        })
      })
    );
  });

  it('should handle errors', async () => {
    axios.request.mockRejectedValue(new Error('Submission failed'));

    await expect(
      documentSubmit(mockApplicationRefNo, mockChannelRef, mockDocumentStore)
    ).rejects.toThrow('Submission failed');
  });
});
describe('redirectingToIbanking', () => {
  const originalWindow = { ...window };

  beforeEach(() => {
    jest.clearAllMocks();
    delete window.location;
    window.location = {
      href: '',
      assign: jest.fn()
    };
  });

  afterEach(() => {
    window.location = originalWindow.location;
  });

  it('should redirect with SSCode when available', async () => {
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockImplementation((param) => param === 'SSCode' ? 'SS123' : null);
    
    axios.request.mockResolvedValue({ data: 'NEWTOKEN' });

    await redirectingToIbanking();

    expect(window.location.href).toBe('https://ibanking.example.comSSCode=NEWTOKEN');
  });

  it('should redirect with existing token when no new token received', async () => {
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockImplementation((param) => param === 'SSCode' ? 'SS123' : null);
    
    axios.request.mockResolvedValue({ data: null });

    await redirectingToIbanking();

    expect(window.location.href).toBe('https://ibanking.example.comSSCode=SS123');
  });

  it('should redirect with empty token when no SSCode available', async () => {
    require('../utils/common/change.utils').getUrl.getParameterByName
      .mockReturnValue(null);
    
    await redirectingToIbanking();

    expect(window.location.href).toBe('https://ibanking.example.comSSCode=');
  });
});
describe('getToken', () => {
  const mockDispatch = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
    axios.get.mockImplementation(url => {
      if (url.includes('authorize-keys')) {
        return Promise.resolve({ data: { keys: ['auth1', 'auth2'] } });
      }
      return Promise.resolve({ data: { keys: ['myinfo1', 'myinfo2'] } });
    });
  });

  it('should fetch both token types', async () => {
    await getToken()(mockDispatch);

    expect(axios.get).toHaveBeenCalledTimes(2);
    expect(axios.get).toHaveBeenCalledWith(process.env.REACT_APP_AUTHORIZE_TKN);
    expect(axios.get).toHaveBeenCalledWith(process.env.REACT_APP_MYINFO_TKN);
    
    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'token/getToken',
      payload: {
        label: 'authorize-keys',
        value: ['auth1', 'auth2']
      }
    });
    expect(mockDispatch).toHaveBeenCalledWith({
      type: 'token/getToken',
      payload: {
        label: 'myinfo-keys',
        value: ['myinfo1', 'myinfo2']
      }
    });
  });

  it('should handle errors', async () => {
    axios.get.mockRejectedValue(new Error('Token fetch failed'));

    await getToken()(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function)); // dispatchError
  });
});
describe('formConfig', () => {
  const mockDispatch = jest.fn();
  const mockCreateResponse = {
    applicants: {
      name_a_1: 'John Doe',
      dob_a_1: '1990-01-01'
    },
    applicant_documents: [{
      journey_type: 'ETC'
    }]
  };

  beforeEach(() => {
    jest.clearAllMocks();
    axios.post.mockResolvedValue({
      data: {
        status: {
          'status-code': '200'
        },
        applicants: {},
        fieldmetadata: {
          data: {
            stages: [
              { stageId: 'ssf-1', fields: [] },
              { stageId: 'ssf-2', fields: [] }
            ]
          }
        }
      }
    });
  });

  it('should make form config request with payload', async () => {
    await formConfig('manual', mockCreateResponse)(mockDispatch);

    expect(axios.post).toHaveBeenCalledWith(
      'https://api.example.com/form-config',
      expect.objectContaining({
        stage: expect.any(Object)
      })
    );
    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'stages/getStage',
        payload: expect.objectContaining({
          id: 'ssf-1',
          formConfig: expect.any(Object)
        })
      })
    );
  });

  it('should merge applicant data from create response', async () => {
    axios.post.mockResolvedValue({
      data: {
        status: { 'status-code': '200' },
        applicants: {},
        fieldmetadata: { data: { stages: [] } }
      }
    });

    await formConfig('manual', mockCreateResponse)(mockDispatch);

    const formConfigResponse = axios.post.mock.calls[0][1];
    expect(formConfigResponse.applicants.name_a_1).toBe('John Doe');
    expect(formConfigResponse.applicants.dob_a_1).toBe('1990-01-01');
  });

  it('should handle technical errors', async () => {
    axios.post.mockResolvedValue({
      data: {
        status: {
          'status-code': '500',
          'status-text': 'Internal error'
        }
      }
    });

    await formConfig('manual', mockCreateResponse)(mockDispatch);

    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'error/getError',
        payload: expect.objectContaining({
          status: '500'
        })
      })
    );
  });
});
