import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import Fields from './Fields';

// Mock Redux hooks
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useDispatch: jest.fn(),
  useSelector: jest.fn(),
}));

// Mock react-router-dom
jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: jest.fn(),
}));

// Mock other dependencies
jest.mock('../../../services/common-service');
jest.mock('../../../services/track-events');
jest.mock('../../../services/ga-track-events');
jest.mock('../../../utils/common/change.utils');

describe('Fields Component', () => {
  let mockDispatch, mockNavigate, mockStore;

  beforeEach(() => {
    mockDispatch = jest.fn();
    mockNavigate = jest.fn();
    useDispatch.mockReturnValue(mockDispatch);
    useNavigate.mockReturnValue(mockNavigate);
    
    // Mock useSelector implementation
    useSelector.mockImplementation((selector) => {
      const mockState = {
        stages: {
          stages: [{
            stageId: 'ssf-1',
            stageInfo: {
              products: [{ product_type: '001', product_category: 'CC' }],
              applicants: {
                full_name_a_1: 'John Doe',
                date_of_birth_a_1: '1990-01-01',
                mobile_number_rwb_a_1: '65-12345678',
              },
              fieldmetadata: {
                data: {
                  stages: []
                }
              }
            }
          }],
          currentStage: 'ssf-1',
          userInput: {
            applicants: {}
          },
          journeyType: 'NTC'
        },
        fielderror: {
          mandatoryFields: []
        },
        valueUpdate: {
          value: false,
          backNavigation: {}
        },
        documentUploadList: {},
        bancaList: {
          bancaDetails: {}
        }
      };
      return selector(mockState);
    });

    mockStore = configureStore({
      reducer: {
        stages: () => ({ stages: [], currentStage: 'ssf-1' }),
        fielderror: () => ({}),
        valueUpdate: () => ({}),
        documentUploadList: () => ({}),
        bancaList: () => ({})
      }
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  // Test cases will go here
});
it('renders basic fields correctly', () => {
  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );
  
  expect(screen.getByRole('form')).toBeInTheDocument();
});
it('handles form submission', async () => {
  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  const form = screen.getByRole('form');
  fireEvent.submit(form);

  await waitFor(() => {
    expect(mockDispatch).toHaveBeenCalled();
  });
});
it('shows age popup when age is invalid', async () => {
  // Mock useSelector to return invalid age
  useSelector.mockImplementation((selector) => {
    const mockState = {
      stages: {
        stages: [{
          stageId: 'ssf-1',
          stageInfo: {
            products: [{ product_type: '001', product_category: 'CC', min_age: 21 }],
            applicants: {
              full_name_a_1: 'John Doe',
              date_of_birth_a_1: '2020-01-01', // Child's age
              mobile_number_rwb_a_1: '65-12345678',
            }
          }
        }],
        currentStage: 'ssf-1',
        userInput: {
          applicants: {}
        }
      },
      fielderror: {
        mandatoryFields: []
      }
    };
    return selector(mockState);
  });

  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  const form = screen.getByRole('form');
  fireEvent.submit(form);

  await waitFor(() => {
    expect(screen.getByText(/age requirement/i)).toBeInTheDocument();
  });
});
it('handles back navigation', () => {
  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  // Simulate back button click
  const backButton = screen.getByText(/back/i);
  fireEvent.click(backButton);

  expect(mockDispatch).toHaveBeenCalled();
});
it('renders document upload when stage is doc', () => {
  // Mock useSelector to return doc stage
  useSelector.mockImplementation((selector) => {
    const mockState = {
      stages: {
        stages: [{
          stageId: 'doc',
          stageInfo: {}
        }],
        currentStage: 'doc',
        userInput: {
          applicants: {}
        }
      }
    };
    return selector(mockState);
  });

  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  expect(screen.queryByRole('form')).not.toBeInTheDocument();
  // Should render DocumentUpload component instead
});
it('handles myinfo fields dispatch', async () => {
  // Mock useSelector to return myinfo authentication
  useSelector.mockImplementation((selector) => {
    const mockState = {
      stages: {
        stages: [{
          stageId: 'ssf-1',
          stageInfo: {
            products: [{ product_type: '001', product_category: 'CC' }],
            applicants: {
              full_name_a_1: 'John Doe',
              date_of_birth_a_1: '1990-01-01',
              mobile_number_rwb_a_1: '65-12345678',
            }
          }
        }],
        currentStage: 'ssf-1',
        userInput: {
          applicants: {}
        },
        myinfoResponse: {
          postal_code_a_1: '123456',
          block_a_1: '123'
        }
      },
      fielderror: {
        mandatoryFields: []
      },
      valueUpdate: {
        otherMyInfo: true
      }
    };
    return selector(mockState);
  });

  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  // Simulate myinfo field change
  const myinfoButton = screen.getByText(/see other myinfo details/i);
  fireEvent.click(myinfoButton);

  await waitFor(() => {
    expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({
      type: 'stages/mergeBasicInputs'
    }));
  });
});

it('validates form fields', async () => {
  // Mock useSelector to return mandatory fields
  useSelector.mockImplementation((selector) => {
    const mockState = {
      stages: {
        stages: [{
          stageId: 'ssf-1',
          stageInfo: {
            products: [{ product_type: '001', product_category: 'CC' }],
            applicants: {
              full_name_a_1: 'John Doe',
              date_of_birth_a_1: '1990-01-01',
            }
          }
        }],
        currentStage: 'ssf-1',
        userInput: {
          applicants: {}
        }
      },
      fielderror: {
        mandatoryFields: ['mobile_number']
      }
    };
    return selector(mockState);
  });

  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  const mobileInput = screen.getByLabelText(/mobile number/i);
  fireEvent.change(mobileInput, { target: { value: '123' }); // Invalid input

  const form = screen.getByRole('form');
  fireEvent.submit(form);

  await waitFor(() => {
    expect(screen.getByText(/continue/i)).toHaveClass('disabled');
  });
});

it('handles insurance validation', async () => {
  // Mock useSelector to return banca details
  useSelector.mockImplementation((selector) => {
    const mockState = {
      stages: {
        stages: [{
          stageId: 'ad-1',
          stageInfo: {
            products: [{ product_type: '001', product_category: 'CC' }],
            applicants: {
              full_name_a_1: 'John Doe',
              date_of_birth_a_1: '1990-01-01',
              credit_limit_consent_a_1: 'N'
            }
          }
        }],
        currentStage: 'ad-1',
        userInput: {
          applicants: {}
        }
      },
      bancaList: {
        bancaDetails: {
          banca_product_applicable_a_1: 'Y',
          eligible_banca_insurances: ['SG-PA'],
          eligible_banca_insurance_informations: [{
            insurance_name: 'Personal Accident',
            insurance_code: 'SG-PA'
          }]
        }
      }
    };
    return selector(mockState);
  });

  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  const insuranceRadio = screen.getByLabelText(/Personal Accident/i);
  fireEvent.click(insuranceRadio);

  await waitFor(() => {
    expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({
      type: 'stages/modifyStage'
    }));
  });
});
it('shows referral code popup when needed', async () => {
  // Mock useSelector to return referral code state
  useSelector.mockImplementation((selector) => {
    const mockState = {
      stages: {
        stages: [{
          stageId: 'ssf-1',
          stageInfo: {
            products: [{ product_type: '001', product_category: 'CC' }],
            applicants: {
              full_name_a_1: 'John Doe',
              date_of_birth_a_1: '1990-01-01',
            }
          }
        }],
        currentStage: 'ssf-1',
        userInput: {
          applicants: {}
        }
      },
      referralcode: {
        refer: 'true',
        referId: null
      }
    };
    return selector(mockState);
  });

  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  const form = screen.getByRole('form');
  fireEvent.submit(form);

  await waitFor(() => {
    expect(screen.getByText(/referral code/i)).toBeInTheDocument();
  });
});

it('handles conditional field rendering', async () => {
  // Mock useSelector to return conditional fields
  useSelector.mockImplementation((selector) => {
    const mockState = {
      stages: {
        stages: [{
          stageId: 'bd-2',
          stageInfo: {
            products: [{ product_type: '001', product_category: 'CC' }],
            applicants: {
              full_name_a_1: 'John Doe',
              date_of_birth_a_1: '1990-01-01',
              select_alt_addresses_a_1: 'PER,AL1'
            }
          }
        }],
        currentStage: 'bd-2',
        userInput: {
          applicants: {
            select_alt_addresses_a_1: 'PER,AL1'
          }
        }
      },
      fielderror: {
        mandatoryFields: ['per_postal_code', 'alt_postal_code_1']
      }
    };
    return selector(mockState);
  });

  render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );

  // Verify conditional fields are rendered
  await waitFor(() => {
    expect(screen.getByLabelText(/permanent address postal code/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/alternate address 1 postal code/i)).toBeInTheDocument();
  });
});
const mockReduxState = (overrides = {}) => {
  const defaultState = {
    stages: {
      stages: [{
        stageId: 'ssf-1',
        stageInfo: {
          products: [{ product_type: '001', product_category: 'CC' }],
          applicants: {
            full_name_a_1: 'John Doe',
            date_of_birth_a_1: '1990-01-01',
            mobile_number_rwb_a_1: '65-12345678',
          }
        }
      }],
      currentStage: 'ssf-1',
      userInput: {
        applicants: {}
      }
    },
    fielderror: {
      mandatoryFields: []
    },
    valueUpdate: {
      value: false,
      backNavigation: {}
    }
  };
  
  return { ...defaultState, ...overrides };
};

const renderFieldsWithState = (stateOverrides = {}) => {
  const state = mockReduxState(stateOverrides);
  useSelector.mockImplementation((selector) => selector(state));
  
  return render(
    <Provider store={mockStore}>
      <Fields />
    </Provider>
  );
};
