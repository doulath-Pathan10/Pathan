import React from 'react';
import { render } from '@testing-library/react';
import App from './App';

// Simple mocks for child components
jest.mock('./router/main', () => () => <div>Main Component</div>);
jest.mock('./shared/components/spinner/spinner', () => () => <div>Spinner</div>);
jest.mock('./shared/components/model/model', () => () => <div>Error Model</div>);
jest.mock('./shared/components/model/dynamic-model', () => () => <div>Dynamic Error Model</div>);
jest.mock('./shared/components/model/idle-time-out', () => () => <div>Idle Timeout Modal</div>);
jest.mock('react-activity-detector', () => ({
  __esModule: true,
  default: () => null
}));

// Mock Redux hooks
jest.mock('react-redux', () => ({
  useSelector: jest.fn(),
  useDispatch: jest.fn(() => jest.fn())
}));

describe('App Component', () => {
  const mockUseSelector = jest.spyOn(require('react-redux'), 'useSelector');

  beforeEach(() => {
    // Default mock return values
    mockUseSelector.mockImplementation(callback => callback({
      loader: { isFetching: null },
      error: { errors: [], exceptionList: [] }
    }));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should render Main component by default', () => {
    const { getByText } = render(<App />);
    expect(getByText('Main Component')).toBeInTheDocument();
  });

  it('should render Spinner when loader is active', () => {
    mockUseSelector.mockImplementation(callback => callback({
      loader: { isFetching: { isFetching: true } },
      error: { errors: [], exceptionList: [] }
    }));
    
    const { getByText } = render(<App />);
    expect(getByText('Spinner')).toBeInTheDocument();
  });

  it('should render Error Model when there are errors', () => {
    mockUseSelector.mockImplementation(callback => callback({
      loader: { isFetching: null },
      error: { errors: ['test error'], exceptionList: [] }
    }));
    
    const { getByText } = render(<App />);
    expect(getByText('Error Model')).toBeInTheDocument();
  });

  it('should render Dynamic Error Model when there are exceptions', () => {
    mockUseSelector.mockImplementation(callback => callback({
      loader: { isFetching: null },
      error: { errors: [], exceptionList: [{ error_header: 'Test' }] }
    }));
    
    const { getByText } = render(<App />);
    expect(getByText('Dynamic Error Model')).toBeInTheDocument();
  });

  it('should not render Idle Timeout Modal by default', () => {
    const { queryByText } = render(<App />);
    expect(queryByText('Idle Timeout Modal')).not.toBeInTheDocument();
  });
});
