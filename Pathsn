import Rules_bd_1 from './Rules_bd_1';
import { authenticateType, getUrl } from '../../utils/common/change.utils';
import rulesUtils from './rules.utils';

// Mock dependencies
jest.mock('../../utils/common/change.utils');
jest.mock('./rules.utils');

const mockAuthenticateType = authenticateType as jest.MockedFunction<typeof authenticateType>;
const mockGetUrl = getUrl as jest.MockedFunction<typeof getUrl>;
const mockRulesUtils = rulesUtils as jest.MockedFunction<typeof rulesUtils>;

// Mock localStorage
const mockLocalStorage = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};

Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage,
  writable: true,
});

describe('Rules_bd_1', () => {
  let mockProps: any;
  let mockStageInfo: any;

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Setup default mock data
    mockProps = [
      [
        {
          field_set_name: 'Basic Information',
          fields: [
            { logical_field_name: 'full_name' },
            { logical_field_name: 'email' },
            { logical_field_name: 'mobile_number' },
            { logical_field_name: 'nationality' },
            { logical_field_name: 'gender' }
          ]
        },
        {
          field_set_name: '   ',
          fields: [
            { 
              logical_field_name: 'product_field',
              sub_product_code: 'SAVINGS_ACCOUNT'
            }
          ]
        }
      ]
    ];

    mockStageInfo = {
      application: {
        source_system_name: '2'
      }
    };

    // Mock getUrl object methods
    mockGetUrl.getParameterByName = jest.fn().mockReturnValue('false');
    mockGetUrl.getStageInfo = jest.fn().mockReturnValue([{
      stageId: 'bd-1',
      stageInfo: {
        applicants: {
          auth_mode_a_1: 'NORMAL',
          account_currency_9_a_1: 'SGD',
          account_currency_a_1: 'SGD'
        }
      }
    }]);

    mockAuthenticateType.mockReturnValue('normal');
    mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
      {
        product_type: 'SAVINGS',
        product_category_name: 'Savings',
        name: 'Basic Savings'
      }
    ]));
    mockRulesUtils.mockReturnValue({ success: true });
  });

  describe('iBanking flow (auth_mode_a_1 === "IX")', () => {
    beforeEach(() => {
      mockGetUrl.getStageInfo.mockReturnValue([{
        stageId: 'bd-1',
        stageInfo: {
          applicants: {
            auth_mode_a_1: 'IX'
          }
        }
      }]);
    });

    it('should handle iBanking authentication correctly', () => {
      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ success: true });
    });

    it('should set non-editable fields for iBanking', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.nonEditable.length).toBeGreaterThan(0);
      expect(validationObj.nonEditable[0]).toContain('full_name');
      expect(validationObj.nonEditable[0]).toContain('email');
      expect(validationObj.nonEditable[0]).toContain('mobile_number');
    });

    it('should hide non-iBanking fields', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.hidden.length).toBeGreaterThan(0);
      expect(validationObj.hidden[0]).toContain('nationality');
      expect(validationObj.hidden[0]).toContain('gender');
    });
  });

  describe('MyInfo flow', () => {
    beforeEach(() => {
      mockAuthenticateType.mockReturnValue('myinfo');
      mockStageInfo.application.source_system_name = '2';
    });

    it('should handle myinfo authentication', () => {
      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ success: true });
    });

    it('should set hidden fields for myinfo', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.hidden.length).toBeGreaterThan(0);
      expect(validationObj.hidden[0]).toContain('dsa_code');
      expect(validationObj.hidden[0]).toContain('nationality');
      expect(validationObj.hidden[0]).toContain('gender');
    });

    it('should set non-editable fields for myinfo', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.nonEditable.length).toBeGreaterThan(0);
      expect(validationObj.nonEditable[0]).toContain('full_name');
      expect(validationObj.nonEditable[0]).toContain('email');
    });
  });

  describe('MyInfo Virtual flow', () => {
    beforeEach(() => {
      mockAuthenticateType.mockReturnValue('normal');
      mockGetUrl.getParameterByName.mockReturnValue('true');
      mockStageInfo.application.source_system_name = '2';
    });

    it('should handle myinfo virtual authentication', () => {
      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ success: true });
    });

    it('should apply same rules as myinfo', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.hidden[0]).toContain('dsa_code');
      expect(validationObj.nonEditable[0]).toContain('full_name');
    });
  });

  describe('Resume flow', () => {
    beforeEach(() => {
      mockAuthenticateType.mockReturnValue('resume');
      mockStageInfo.application.source_system_name = '2';
    });

    it('should handle resume authentication', () => {
      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ success: true });
    });
  });

  describe('Manual flow', () => {
    beforeEach(() => {
      mockAuthenticateType.mockReturnValue('manual');
    });

    it('should handle manual authentication', () => {
      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ success: true });
    });

    it('should set correct hidden fields for manual', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.hidden[0]).toContain('ownership_status');
      expect(validationObj.hidden[0]).toContain('education_level');
    });

    it('should set correct non-editable fields for manual', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.nonEditable[0]).toContain('full_name');
      expect(validationObj.nonEditable[0]).toContain('email');
    });
  });

  describe('Default flow', () => {
    beforeEach(() => {
      mockAuthenticateType.mockReturnValue('normal');
      mockStageInfo.application.source_system_name = '1';
    });

    it('should handle default authentication', () => {
      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ success: true });
    });

    it('should only hide myInfo consent fields', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.hidden[0]).toContain('see_other_myInfo_details');
      expect(validationObj.hidden[0]).toContain('see_other_myInfo_details_consent');
    });
  });

  describe('Account currency handling', () => {
    beforeEach(() => {
      mockAuthenticateType.mockReturnValue('myinfo');
      mockStageInfo.application.source_system_name = '2';
    });

    it('should hide account currency fields when empty', () => {
      mockGetUrl.getStageInfo.mockReturnValue([{
        stageId: 'bd-1',
        stageInfo: {
          applicants: {
            account_currency_9_a_1: '',
            account_currency_a_1: ''
          }
        }
      }]);

      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.hidden[0]).toContain('account_currency_9');
      expect(validationObj.hidden[0]).toContain('account_currency');
    });

    it('should handle RWB account currency fields', () => {
      mockGetUrl.getStageInfo.mockReturnValue([{
        stageId: 'bd-1',
        stageInfo: {
          applicants: {
            account_currency_rwb_field1_p_1: 'value1',
            account_currency_rwb_field2_p_1: 'value2'
          }
        }
      }]);

      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj.nonEditable[0]).toContain('account_currency_rwb_field1');
      expect(validationObj.nonEditable[0]).toContain('account_currency_rwb_field2');
    });
  });

  describe('Product filtering', () => {
    it('should process products from localStorage', () => {
      const products = [
        {
          product_type: 'SAVINGS',
          product_category_name: 'Savings',
          name: 'Premium Savings'
        }
      ];
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify(products));

      Rules_bd_1(mockProps, mockStageInfo);

      expect(mockLocalStorage.getItem).toHaveBeenCalledWith('products');
      expect(mockRulesUtils).toHaveBeenCalled();
    });

    it('should handle empty products array', () => {
      mockLocalStorage.getItem.mockReturnValue('[]');

      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(result).toEqual({ success: true });
    });

    it('should handle null products', () => {
      mockLocalStorage.getItem.mockReturnValue(null);

      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(result).toEqual({ success: true });
    });
  });

  describe('Validation object structure', () => {
    it('should always create validation object with required properties', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const validationObj = callArgs[1];

      expect(validationObj).toHaveProperty('nonEditable');
      expect(validationObj).toHaveProperty('hidden');
      expect(validationObj).toHaveProperty('modifyVisibility');
      expect(Array.isArray(validationObj.nonEditable)).toBe(true);
      expect(Array.isArray(validationObj.hidden)).toBe(true);
      expect(Array.isArray(validationObj.modifyVisibility)).toBe(true);
    });
  });

  describe('Field set filtering', () => {
    it('should filter out empty field set names', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const fieldSets = callArgs[0];

      // Should filter out field sets with name "   "
      const emptyFieldSets = fieldSets[0].filter((fs: any) => fs.field_set_name === '   ');
      expect(emptyFieldSets.length).toBe(0);
    });

    it('should keep Basic Information field set', () => {
      Rules_bd_1(mockProps, mockStageInfo);

      const callArgs = mockRulesUtils.mock.calls[0];
      const fieldSets = callArgs[0];

      const basicInfoSet = fieldSets[0].find((fs: any) => fs.field_set_name === 'Basic Information');
      expect(basicInfoSet).toBeDefined();
    });
  });

  describe('Function return', () => {
    it('should return result from rulesUtils', () => {
      const expectedResult = { status: 'success', data: 'test' };
      mockRulesUtils.mockReturnValue(expectedResult);

      const result = Rules_bd_1(mockProps, mockStageInfo);

      expect(result).toEqual(expectedResult);
    });
  });

  describe('Error handling', () => {
    it('should handle missing props gracefully', () => {
      const emptyProps = [[]];
      
      expect(() => Rules_bd_1(emptyProps, mockStageInfo)).not.toThrow();
    });

    it('should handle missing stage info gracefully', () => {
      const emptyStageInfo = {};
      
      expect(() => Rules_bd_1(mockProps, emptyStageInfo)).not.toThrow();
    });
  });
});
