import React from 'react';
import { render, screen, act } from '@testing-library/react';
import SignaturePreview from './SignaturePreview';
import SignatureCanvas from 'react-signature-canvas';

// Mock the react-signature-canvas module
jest.mock('react-signature-canvas', () => {
  return jest.fn().mockImplementation(() => {
    return {
      clear: jest.fn(),
      off: jest.fn(),
      on: jest.fn(),
      fromData: jest.fn(),
      toData: jest.fn().mockReturnValue([]),
      toDataURL: jest.fn().mockReturnValue('data:image/jpeg;base64,mockBase64String'),
    };
  });
});

// Mock the common-service functions
jest.mock('../../../services/common-service', () => ({
  getBase64IntArray: jest.fn().mockReturnValue('mockBase64Array'),
  getIntArrayfromBase64: jest.fn().mockReturnValue([]),
}));

describe('SignaturePreview Component', () => {
  const mockHandleSignatureEnd = jest.fn();
  const defaultProps = {
    viewSignature: null,
    show: true,
    handleSignatureEnd: mockHandleSignatureEnd,
    clear: false,
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render the component', () => {
    render(<SignaturePreview {...defaultProps} />);
    expect(SignatureCanvas).toHaveBeenCalled();
  });

  it('should call clear when clear prop changes to true', () => {
    const { rerender } = render(<SignaturePreview {...defaultProps} />);
    
    // Initial render shouldn't call clear
    expect(SignatureCanvas.mock.results[0].value.clear).not.toHaveBeenCalled();
    
    // Rerender with clear=true
    rerender(<SignaturePreview {...defaultProps} clear={true} />);
    expect(SignatureCanvas.mock.results[0].value.clear).toHaveBeenCalled();
  });

  it('should turn off signature canvas when show becomes false', () => {
    const { rerender } = render(<SignaturePreview {...defaultProps} />);
    
    // Initial render with show=true
    expect(SignatureCanvas.mock.results[0].value.off).not.toHaveBeenCalled();
    
    // Rerender with show=false
    rerender(<SignaturePreview {...defaultProps} show={false} />);
    expect(SignatureCanvas.mock.results[0].value.off).toHaveBeenCalled();
  });

  it('should load signature data when viewSignature is provided and show is true', () => {
    const viewSignature = 'mockBase64Signature';
    render(<SignaturePreview {...defaultProps} viewSignature={viewSignature} />);
    
    expect(require('../../../services/common-service').getIntArrayfromBase64).toHaveBeenCalledWith(viewSignature);
    expect(SignatureCanvas.mock.results[0].value.fromData).toHaveBeenCalledWith([]);
    expect(SignatureCanvas.mock.results[0].value.on).toHaveBeenCalled();
  });

  it('should load signature data when viewSignature is provided and show is false', () => {
    const viewSignature = 'mockBase64Signature';
    render(<SignaturePreview {...defaultProps} viewSignature={viewSignature} show={false} />);
    
    expect(require('../../../services/common-service').getIntArrayfromBase64).toHaveBeenCalledWith(viewSignature);
    expect(SignatureCanvas.mock.results[0].value.fromData).toHaveBeenCalledWith([]);
    expect(SignatureCanvas.mock.results[0].value.on).not.toHaveBeenCalled();
  });

  it('should handle signature end event correctly', () => {
    render(<SignaturePreview {...defaultProps} />);
    
    // Simulate signature end event
    act(() => {
      const onEnd = SignatureCanvas.mock.calls[0][0].onEnd;
      onEnd();
    });
    
    expect(require('../../../services/common-service').getBase64IntArray).toHaveBeenCalledWith([]);
    expect(SignatureCanvas.mock.results[0].value.toDataURL).toHaveBeenCalledWith('image/jpeg');
    expect(mockHandleSignatureEnd).toHaveBeenCalledWith({
      array: 'mockBase64Array',
      jpeg: 'mockBase64String'
    });
  });

  it('should not call fromData when viewSignature is null', () => {
    render(<SignaturePreview {...defaultProps} viewSignature={null} />);
    expect(SignatureCanvas.mock.results[0].value.fromData).not.toHaveBeenCalled();
  });
});
