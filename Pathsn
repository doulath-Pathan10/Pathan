import './signature.scss';
import { useEffect, useState } from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { stagesAction } from "../../../utils/store/stages-slice";
import { KeyWithAnyModel, StoreModel } from "../../../utils/model/common-model";
import ReactDOM from 'react-dom';
import SignaturePreview from './signature-preview';
import { getUrl } from "../../../utils/common/change.utils"
import { postRequest, signatureSubmit } from '../../../services/common-service';
import axios from 'axios';
import { documentClientContext, getDocumentMetaData } from '../document-upload/document-upload.utils';

const SignModel = (props: KeyWithAnyModel) => {
  const { handlebuttonClick, show, viewSignature, fieldName, setValue, data, popupTitle } = props;
  const [signature, setSignature] = useState<any>(null);
  const [pngSignature, setPngSignature] = useState<any>(null);
  const dispatch = useDispatch();

  const [error, setError] = useState('');
  const [charCount, setCharCount] = useState('');
  const stageSelector = useSelector((state: StoreModel) => state.stages.stages);
  const userInputSelector = useSelector((state: StoreModel) => state.stages.userInput);
  const channelReference = stageSelector[0].stageInfo.application.channel_reference;

  const docRequest = {
    origin: "front-line-supporting-document",
    // getUrl.getFlow() === 'first-director-authorized' ||
    // getUrl.getFlow() === 'single-director-authorized' ||
    // getUrl.getFlow() === 'single-director-partnership-company-authorized'
    //   ? '1'
    //   : '2',
    // docBytes: signature,
    // docCategory: 'R0006',
    // docType: 'T0308',
    documentCategoryCode:"R0006",
    documentTypeCode:"T0308",
    // applicantNo: 1,
    applicantId:1,
    imageOrder: 1,
    period: 0,
    isWatermarkRequired: "N",
    documentOptionSequence: 1
  };

  useEffect(() => {
    if (viewSignature) {
      setSignature(viewSignature);
    }
  }, []);

  const clearSignature = () => {
    setSignature(null);
    setPngSignature(null);
  };

  const onclickEvent = () => {
    if (fieldName === 'signUser') {
      saveSignature();
    } else {
      saveOthersTextarea(charCount);
    }
  };

  const saveSignature = () => {
    signatureRequest();
  };

  const handleSignatureEnd = (data: any) => {
    setSignature(data.array);
    setPngSignature(data.jpeg);
  };

  /*textarea*/
  const handleChange = (e: any) => {
    if (e.target.value.length > 160) {
      setError('Characters limit exceeded');
    } else if (fieldName === 'purposeOther' || fieldName === 'fundReasonOther') {
      const regex = /^[a-zA-Z0-9\s]*$/;
      const isValid = regex.test(e.target.value);
      if (!isValid) {
        setError('Special Characters not allowed');
      } else {
        setError('');
      }
      setCharCount(e.target.value);
    } else {
      setError('');
      setCharCount(e.target.value);
    }
  };

  const saveOthersTextarea = (char: any) => {
    setValue(char);
    handlebuttonClick(false);
  };


  const signatureRequest = () => {
    dispatch(stagesAction.setSignatureDocument(signature));
    dispatch(stagesAction.setActivateformData(true));
    handlebuttonClick(false);
    /** Single file upload -- child method */
    let formData
    const signatureUpload = async () => {
      const dataURL = `data:image/jpeg;base64,${pngSignature}`;
      const byteString = atob(dataURL.split(',')[1]);
      const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
      const ab = new ArrayBuffer(byteString.length);
      const ia = new Uint8Array(ab);
      for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
      }
      const sendData: any = new Blob([ab], { type: mimeString });
      formData = new FormData();
      formData.append('file', sendData, "sign");
      formData.append("documentJson", JSON.stringify(docRequest));
      sendData&& formData && signatureSubmit(channelReference, formData, dispatch )
    }
    signatureUpload();
  }

  useEffect(() => {
    if (
      stageSelector[0].stageInfo.applicants[fieldName] ||
      userInputSelector.applicants[fieldName]
    ) {
      const userData =
        stageSelector[0].stageInfo.applicants[fieldName] || userInputSelector.applicants[fieldName];
      setCharCount(userData);
    }
  }, []);
  /*text area end*/

  const portalElement: any = document.getElementById('model-root');
  return ReactDOM.createPortal(
    <div className="signModel">
      <div className="sign__popup">
        <div className="sign--header">
          <div className="sign--header__left" onClick={() => handlebuttonClick()}></div>
          <div className="sign--header__middle">
            {' '}
            {fieldName === 'countryTinOther' ||
              fieldName === 'purposeOther' ||
              fieldName === 'fundReasonOther'
              ? popupTitle
              : 'Signature'}
          </div>
          {fieldName === 'countryTinOther' ||
            fieldName === 'purposeOther' ||
            fieldName === 'fundReasonOther' ? (
            ''
          ) : (
            <button
              disabled={signature ? false : true}
              className={signature ? 'sign--header__right--blue' : 'sign--header__right'}
              onClick={() => clearSignature()}
            >
              Reset
            </button>
          )}
        </div>
        {fieldName === 'countryTinOther' ||
          fieldName === 'purposeOther' ||
          fieldName === 'fundReasonOther' ? (
          <>
            <div className="textarea__popup">
              <div className="title__textarea">Please provide details</div>
              <div className="char__textarea">
                <textarea autoFocus={true} value={charCount} onChange={handleChange}></textarea>
                <div className="char__count">{charCount.length + '/' + data.maxLength}</div>
              </div>
            </div>
          </>
        ) : (
          <div className="sign--body">
            <div className="sign--body__title">Sign in the box below</div>
            <div className="sign--body__pad">
              <SignaturePreview
                clear={!signature}
                viewSignature={viewSignature}
                show={show}
                handleSignatureEnd={handleSignatureEnd}
              />
            </div>
          </div>
        )}
        {fieldName === 'signUser' && (
          <div className="sign--rotate">
            <div className="sign--rotate__img"></div>
            <div className="sign--rotate__desc">
              Rotate your phone for a larger space to sign in
            </div>
          </div>
        )}
        <div className="sign--footer">
          {/* {fieldName === 'purposeOther' || fieldName === 'fundReasonOther'? <button   disabled={charCount ? false : true }  className={charCount ? 'continue' : 'continue  form-invalid'}  onClick={() => saveOthersTextarea((charCount))}>Confirm</button> :
          <button disabled={signature ? false : true } className={signature ? 'continue' : 'continue  form-invalid'} onClick={() => saveSignature()}>Confirm signature</button>
        } */}
          <button
            disabled={fieldName === 'signUser' ? !signature : !charCount}
            className={signature || charCount ? 'continue' : 'continue form-invalid'}
            onClick={() => onclickEvent()}
          >
            {fieldName === 'signUser' ? <>Confirm signature</> : <>Confirm</>}
          </button>
        </div>
        {error && <span className="error-msg">{error}</span>}
      </div>
    </div>,
    portalElement
  );
};

export default SignModel;
Please write test cases using jest with RTL
