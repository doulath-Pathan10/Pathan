import React from 'react';
import { render, screen, act, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import store from './utils/store/store';

// Mock child components
jest.mock('./router/main', () => () => <div data-testid="main-component">Main Component</div>);
jest.mock('./shared/components/model/model', () => ({ name, handlebuttonClick }: any) => (
  <div data-testid="error-model">
    Model Component - {name}
    <button onClick={handlebuttonClick}>Handle Error</button>
  </div>
));
jest.mock('./shared/components/spinner/spinner', () => () => <div data-testid="spinner">Spinner Component</div>);
jest.mock('./shared/components/model/dynamic-model', () => ({ errorList }: any) => (
  <div data-testid="dynamic-model">
    DynamicModel Component - {errorList.length} errors
  </div>
));
jest.mock('./shared/components/model/idle-time-out', () => ({ handlePopUpClick }: any) => (
  <div data-testid="idle-timeout-model">
    IdleTimeOutModel Component
    <button onClick={handlePopUpClick}>Close</button>
  </div>
));

// Mock activity detector
const mockActivityDetector = jest.fn();
jest.mock('react-activity-detector', () => ({
  __esModule: true,
  default: (props: any) => {
    mockActivityDetector(props);
    return null;
  },
}));

// Mock track events
const mockTriggerAdobeEvent = jest.fn();
jest.mock('./services/track-events', () => ({
  triggerAdobeEvent: mockTriggerAdobeEvent,
}));

// Mock Redux hooks
const mockUseSelector = jest.fn();
const mockUseDispatch = jest.fn();
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useSelector: () => mockUseSelector(),
  useDispatch: () => mockUseDispatch,
}));

describe('App Component', () => {
  const originalAddEventListener = window.addEventListener;
  const originalRemoveEventListener = window.removeEventListener;
  let addEventListenerSpy: jest.SpyInstance;
  let removeEventListenerSpy: jest.SpyInstance;

  beforeEach(() => {
    jest.clearAllMocks();
    addEventListenerSpy = jest.spyOn(window, 'addEventListener');
    removeEventListenerSpy = jest.spyOn(window, 'removeEventListener');
    
    // Default mock state
    mockUseSelector.mockReturnValue({
      loader: { isFetching: { isFetching: false } },
      error: { errors: [], exceptionList: [] },
    });
  });

  afterAll(() => {
    window.addEventListener = originalAddEventListener;
    window.removeEventListener = originalRemoveEventListener;
  });

  it('renders without crashing and shows main component', () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByTestId('main-component')).toBeInTheDocument();
    expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
    expect(screen.queryByTestId('error-model')).not.toBeInTheDocument();
  });

  it('sets up and cleans up contextmenu event listeners', () => {
    const { unmount } = render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(addEventListenerSpy).toHaveBeenCalledWith(
      'contextmenu',
      expect.any(Function)
    );
    
    unmount();
    
    expect(removeEventListenerSpy).toHaveBeenCalledWith(
      'contextmenu',
      expect.any(Function)
    );
  });

  it('shows spinner when loader is active', () => {
    mockUseSelector.mockReturnValue({
      loader: { isFetching: { isFetching: true } },
      error: { errors: [], exceptionList: [] },
    });
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByTestId('spinner')).toBeInTheDocument();
    expect(screen.queryByTestId('error-model')).not.toBeInTheDocument();
  });

  it('shows error model when errors exist', () => {
    mockUseSelector.mockReturnValue({
      loader: { isFetching: { isFetching: false } },
      error: { errors: ['Test error'], exceptionList: [] },
    });
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByTestId('error-model')).toBeInTheDocument();
    expect(screen.getByText('Model Component - globalError')).toBeInTheDocument();
    expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
  });

  it('shows dynamic model when exceptionList exists', () => {
    mockUseSelector.mockReturnValue({
      loader: { isFetching: { isFetching: false } },
      error: { errors: [], exceptionList: [{ error_header: 'Test error' }] },
    });
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByTestId('dynamic-model')).toBeInTheDocument();
    expect(screen.getByText('DynamicModel Component - 1 errors')).toBeInTheDocument();
  });

  it('configures activity detector with correct timeout', () => {
    process.env.REACT_APP_RTOB_APP_IDLE_TIMEOUT_DURATION = '5';
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(mockActivityDetector).toHaveBeenCalledWith({
      enabled: true,
      timeout: 50000, // 5 * 10000
      onIdle: expect.any(Function),
      onActive: expect.any(Function),
      name: "default"
    });
  });

  it('handles idle state correctly', () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    // Get the onIdle callback from the activity detector mock
    const onIdle = mockActivityDetector.mock.calls[0][0].onIdle;
    
    act(() => {
      onIdle();
    });
    
    expect(screen.getByTestId('idle-timeout-model')).toBeInTheDocument();
  });

  it('does not show idle popup when loader is active', () => {
    mockUseSelector.mockReturnValue({
      loader: { isFetching: { isFetching: true } },
      error: { errors: [], exceptionList: [] },
    });
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    const onIdle = mockActivityDetector.mock.calls[0][0].onIdle;
    
    act(() => {
      onIdle();
    });
    
    expect(screen.queryByTestId('idle-timeout-model')).not.toBeInTheDocument();
  });

  it('closes idle popup when close button is clicked', () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    const onIdle = mockActivityDetector.mock.calls[0][0].onIdle;
    
    act(() => {
      onIdle();
    });
    
    expect(screen.getByTestId('idle-timeout-model')).toBeInTheDocument();
    
    fireEvent.click(screen.getByText('Close'));
    
    expect(screen.queryByTestId('idle-timeout-model')).not.toBeInTheDocument();
  });

  it('triggers formError Adobe event when errors exist', () => {
    mockUseSelector.mockReturnValue({
      loader: { isFetching: { isFetching: false } },
      error: { 
        errors: ['Test error'], 
        exceptionList: [{ error_header: 'Test exception' }] 
      },
    });
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(mockTriggerAdobeEvent).toHaveBeenCalledWith('formError');
  });

  it('sets up unload event listener for form abandonment tracking', () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(addEventListenerSpy).toHaveBeenCalledWith(
      'unload',
      expect.any(Function)
    );
  });

  it('triggers formAbandonment event on unload', () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    // Find and call the unload handler
    const unloadCall = addEventListenerSpy.mock.calls.find(
      call => call[0] === 'unload'
    );
    const unloadHandler = unloadCall[1];
    
    act(() => {
      unloadHandler();
    });
    
    expect(mockTriggerAdobeEvent).toHaveBeenCalledWith(
      'formAbandonment',
      'BrowserClose'
    );
  });

  it('handles error button click', () => {
    mockUseSelector.mockReturnValue({
      loader: { isFetching: { isFetching: false } },
      error: { errors: ['Test error'], exceptionList: [] },
    });
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    fireEvent.click(screen.getByText('Handle Error'));
    // Add your assertions for what should happen on button click
  });
});
