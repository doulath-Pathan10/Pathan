import Rules_bd_1 from './Rules_bd_1';
import rulesUtils from './rules.utils';
import { authenticateType, getUrl } from '../../utils/common/change.utils';

// Mock all dependencies
jest.mock('./rules.utils', () => jest.fn(() => ({})));
jest.mock('../../utils/common/change.utils', () => ({
  authenticateType: jest.fn(),
  getUrl: {
    getParameterByName: jest.fn(),
    getStageInfo: jest.fn()
  }
}));

describe('Rules_bd_1', () => {
  const mockProps = [[
    {
      field_set_name: 'Basic Information',
      fields: [
        { logical_field_name: 'full_name' },
        { logical_field_name: 'email' },
        { logical_field_name: 'mobile_number' },
        { logical_field_name: 'account_currency_9' },
        { logical_field_name: 'account_currency' },
        { logical_field_name: 'contact_preference_casa' },
        { logical_field_name: 'dsa_code' },
        { logical_field_name: 'nationality' },
        { logical_field_name: 'other_field' }
      ]
    },
    {
      field_set_name: '   ',
      fields: [
        { 
          logical_field_name: 'product_field',
          sub_product_code: ['prod1', 'prod2']
        }
      ]
    }
  ]];

  const createStageInfo = (overrides = {}) => ({
    application: {
      source_system_name: '2'
    },
    products: [
      { product_type: 'prod1', product_category_name: 'Category1', name: 'Product1' },
      { product_type: 'prod2', product_category_name: 'Category2', name: 'Product2' }
    ],
    applicants: {
      auth_mode_a_1: '',
      account_currency_9_a_1: 'USD',
      account_currency_a_1: 'USD',
      account_currency_rwb_1_p_1: 'EUR',
      account_currency_rwb_2_p_1: 'GBP'
    },
    ...overrides
  });

  beforeEach(() => {
    jest.clearAllMocks();
    localStorage.clear();
    localStorage.setItem('products', JSON.stringify([
      { product_type: 'prod1', product_category_name: 'Category1', name: 'Product1' },
      { product_type: 'prod2', product_category_name: 'Category2', name: 'Product2' }
    ]));
    
    (getUrl.getStageInfo as jest.Mock).mockReturnValue([{
      stageId: 'bd-1',
      stageInfo: createStageInfo()
    }]);
  });

  describe('iBanking Authentication', () => {
    it('should set correct validation for iBanking auth', () => {
      const stageInfo = createStageInfo({
        applicants: {
          auth_mode_a_1: 'IX'
        }
      });
      
      (getUrl.getStageInfo as jest.Mock).mockReturnValue([{
        stageId: 'bd-1',
        stageInfo: stageInfo
      }]);

      const result = Rules_bd_1(mockProps, stageInfo);
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          nonEditable: [expect.arrayContaining([
            "full_name",
            "email",
            "mobile_number",
            "account_currency_9",
            "account_currency",
            "contact_preference_casa"
          ])],
          hidden: [expect.arrayContaining(['other_field'])]
        })
      );
    });
  });

  describe('MyInfo/Resume Authentication', () => {
    beforeEach(() => {
      (authenticateType as jest.Mock).mockReturnValue('myinfo');
      (getUrl.getParameterByName as jest.Mock).mockReturnValue('true');
    });

    it('should set correct validation for MyInfo auth', () => {
      const result = Rules_bd_1(mockProps, createStageInfo());
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          nonEditable: [expect.arrayContaining([
            "full_name",
            "email",
            "mobile_number",
            "residential_address",
            "account_currency_9",
            "account_currency"
          ])],
          hidden: [expect.arrayContaining([
            "dsa_code",
            "nationality",
            "country_of_birth"
          ])]
        })
      );
    });

    it('should handle empty account currency fields', () => {
      const stageInfo = createStageInfo({
        applicants: {
          account_currency_9_a_1: '',
          account_currency_a_1: ''
        }
      });
      
      (getUrl.getStageInfo as jest.Mock).mockReturnValue([{
        stageId: 'bd-1',
        stageInfo: stageInfo
      }]);

      const result = Rules_bd_1(mockProps, stageInfo);
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          hidden: [expect.arrayContaining([
            "account_currency_9",
            "account_currency"
          ])]
        })
      );
    });

    it('should include RWB account currencies in nonEditable', () => {
      const result = Rules_bd_1(mockProps, createStageInfo());
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          nonEditable: [expect.arrayContaining([
            "account_currency_rwb_1",
            "account_currency_rwb_2"
          ])]
        })
      );
    });
  });

  describe('Manual Authentication', () => {
    beforeEach(() => {
      (authenticateType as jest.Mock).mockReturnValue('manual');
    });

    it('should set correct validation for manual auth', () => {
      const result = Rules_bd_1(mockProps, createStageInfo());
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          nonEditable: [expect.arrayContaining([
            "full_name",
            "email",
            "mobile_number",
            "residential_status"
          ])],
          hidden: [expect.arrayContaining([
            "ownership_status",
            "education_level",
            "nationality"
          ])]
        })
      );
    });
  });

  describe('Default Authentication', () => {
    beforeEach(() => {
      (authenticateType as jest.Mock).mockReturnValue('other');
    });

    it('should set default hidden fields', () => {
      const result = Rules_bd_1(mockProps, createStageInfo());
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          hidden: [expect.arrayContaining([
            "see_other_myInfo_details",
            "see_other_myInfo_details_consent"
          ])]
        })
      );
    });
  });

  describe('Field Grouping Logic', () => {
    it('should group fields by product category and name', () => {
      (authenticateType as jest.Mock).mockReturnValue('manual');
      
      const result = Rules_bd_1(mockProps, createStageInfo());
      
      // Verify the field grouping logic by checking the props passed to rulesUtils
      const [updatedProps] = (rulesUtils as jest.Mock).mock.calls[0];
      expect(updatedProps.length).toBeGreaterThan(1);
      expect(updatedProps.some((field: any) => field.field_set_name.includes('Category1 - Product1'))).toBe(true);
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty products array', () => {
      localStorage.setItem('products', '[]');
      const result = Rules_bd_1(mockProps, createStageInfo());
      expect(result).toBeDefined();
    });

    it('should handle missing field_set_name', () => {
      const modifiedProps = [[{ fields: [] }]];
      const result = Rules_bd_1(modifiedProps, createStageInfo());
      expect(result).toBeDefined();
    });

    it('should handle empty stageInfo', () => {
      const result = Rules_bd_1(mockProps, {} as any);
      expect(result).toBeDefined();
    });

    it('should handle missing applicants', () => {
      const stageInfo = createStageInfo();
      delete stageInfo.applicants;
      (getUrl.getStageInfo as jest.Mock).mockReturnValue([{
        stageId: 'bd-1',
        stageInfo: stageInfo
      }]);
      const result = Rules_bd_1(mockProps, stageInfo);
      expect(result).toBeDefined();
    });

    it('should handle resume authentication', () => {
      (authenticateType as jest.Mock).mockReturnValue('resume');
      (getUrl.getParameterByName as jest.Mock).mockReturnValue('false');
      
      const result = Rules_bd_1(mockProps, createStageInfo());
      expect(result).toBeDefined();
    });
  });
});
