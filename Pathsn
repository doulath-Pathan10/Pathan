import { AppDispatch } from "../../../services/common-service";
import { getFields } from "../your-file-path";
import { fieldErrorAction, stagesAction } from "../../../utils/store";
import { KeyWithAnyModel, StageDetails } from "../../../utils/model/common-model";

// Mock the dependencies
jest.mock("../../../utils/common/change.utils");
jest.mock("../../../utils/store/field-error-slice");
jest.mock("../../../utils/store/stages-slice");

describe("getFields function - Error Handling", () => {
  const mockDispatch = jest.fn() as jest.MockedFunction<AppDispatch>;
  
  const baseStageDetails: StageDetails = {
    stageId: "testStage",
    stageInfo: {
      fieldmetadata: {
        data: {
          stages: [
            {
              stageId: "testStage",
              fields: [
                {
                  logical_field_name: "mobile_number_rwb",
                  component_type: "Text",
                  rwb_label_name: "Mobile",
                  editable: true
                },
                {
                  logical_field_name: "home_phone_number_rwb",
                  component_type: "Text",
                  rwb_label_name: "Home Phone",
                  editable: true
                },
                {
                  logical_field_name: "mobile_1",
                  component_type: "Text",
                  rwb_label_name: "Mobile 1",
                  editable: true
                }
              ]
            }
          ]
        }
      }
    }
  };

  beforeEach(() => {
    jest.clearAllMocks();
    // Reset journey type mock
    require("../../../utils/common/change.utils").getUrl.getJourneyType = jest.fn(() => undefined);
  });

  it("should handle empty stages array input", () => {
    const thunk = getFields([], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle undefined stageInfo", () => {
    const invalidStageDetails = {
      ...baseStageDetails,
      stageInfo: undefined
    };
    
    const thunk = getFields([invalidStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle undefined fieldmetadata", () => {
    const invalidStageDetails = {
      ...baseStageDetails,
      stageInfo: {
        fieldmetadata: undefined
      }
    };
    
    const thunk = getFields([invalidStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle undefined data in fieldmetadata", () => {
    const invalidStageDetails = {
      ...baseStageDetails,
      stageInfo: {
        fieldmetadata: {
          data: undefined
        }
      }
    };
    
    const thunk = getFields([invalidStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle undefined stages in data", () => {
    const invalidStageDetails = {
      ...baseStageDetails,
      stageInfo: {
        fieldmetadata: {
          data: {
            stages: undefined
          }
        }
      }
    };
    
    const thunk = getFields([invalidStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle empty stages in data", () => {
    const invalidStageDetails = {
      ...baseStageDetails,
      stageInfo: {
        fieldmetadata: {
          data: {
            stages: []
          }
        }
      }
    };
    
    const thunk = getFields([invalidStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle undefined fields in stage", () => {
    const invalidStageDetails = {
      ...baseStageDetails,
      stageInfo: {
        fieldmetadata: {
          data: {
            stages: [
              {
                stageId: "testStage",
                fields: undefined
              }
            ]
          }
        }
      }
    };
    
    const thunk = getFields([invalidStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle empty fields in stage", () => {
    const invalidStageDetails = {
      ...baseStageDetails,
      stageInfo: {
        fieldmetadata: {
          data: {
            stages: [
              {
                stageId: "testStage",
                fields: []
              }
            ]
          }
        }
      }
    };
    
    const thunk = getFields([invalidStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle undefined phoneSelector", () => {
    const thunk = getFields([baseStageDetails], undefined as any);
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle undefined fields in phoneSelector", () => {
    const thunk = getFields([baseStageDetails], { fields: undefined } as any);
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle empty fields array in phoneSelector", () => {
    const thunk = getFields([baseStageDetails], { fields: [] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle non-existent field in phoneSelector", () => {
    const thunk = getFields([baseStageDetails], { fields: ["non_existent_field"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });

  it("should handle error in getJourneyType", () => {
    require("../../../utils/common/change.utils").getUrl.getJourneyType = jest.fn(() => {
      throw new Error("API Error");
    });
    
    const thunk = getFields([baseStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    // Should still process fields even if journey type fails
    expect(result[0].logical_field_name).toBe("mobile_number");
    expect(result[0].hide_remove_btn).toBeUndefined(); // Since journey type failed
  });

  it("should handle malformed field data (missing logical_field_name)", () => {
    const malformedStageDetails = {
      ...baseStageDetails,
      stageInfo: {
        fieldmetadata: {
          data: {
            stages: [
              {
                stageId: "testStage",
                fields: [
                  {
                    // Missing logical_field_name
                    component_type: "Text",
                    rwb_label_name: "Mobile",
                    editable: true
                  }
                ]
              }
            ]
          }
        }
      }
    };
    
    const thunk = getFields([malformedStageDetails], { fields: ["mobile_number_rwb"] });
    const result = thunk(mockDispatch);
    
    expect(result).toEqual([]);
    expect(mockDispatch).not.toHaveBeenCalled();
  });
});
