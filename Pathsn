import RulesSSF from './RulesSSF';
import rulesUtils from './rules.utils';
import { authenticateType, filterDisableFields } from '../../utils/common/change.utils';

// Mock all dependencies
jest.mock('./rules.utils', () => jest.fn(() => ({})));
jest.mock('../../utils/common/change.utils', () => ({
  authenticateType: jest.fn(),
  filterDisableFields: jest.fn((fields, missing, editable) => missing),
  getUrl: {
    getParameterByName: jest.fn()
  }
}));

describe('RulesSSF', () => {
  const mockProps = [[
    {
      field_set_name: '   ',
      fields: [
        { logical_field_name: 'email' },
        { logical_field_name: 'mobile_number' },
        { logical_field_name: 'account_currency_9' },
        { logical_field_name: 'full_name' },
        { logical_field_name: 'other_field' },
        { logical_field_name: 'no_of_accounts_rwb' },
        { logical_field_name: 'mode_of_operation' },
        { logical_field_name: 'pass_exp_dt' }
      ]
    }
  ]];

  const baseStageInfo = {
    application: {
      source_system_name: '2'
    },
    products: [
      { product_category: 'TD', product_type: '337', product_category_name: 'Term Deposit', name: 'TD Account' },
      { product_category: 'CA', product_type: '456', product_category_name: 'Current Account', name: 'CA Account' }
    ],
    applicants: {
      auth_mode_a_1: 'IX',
      mobile_number_a_1: '12345678',
      email_a_1: 'test@example.com',
      account_currency_9_a_1: 'USD',
      account_currency_a_1: 'USD'
    }
  };

  beforeEach(() => {
    jest.clearAllMocks();
    localStorage.clear();
    localStorage.setItem('products', JSON.stringify([
      { product_type: '337', product_category_name: 'Term Deposit', name: 'TD Account' },
      { product_type: '456', product_category_name: 'Current Account', name: 'CA Account' }
    ]));
  });

  describe('Authentication Scenarios', () => {
    it('should handle MyInfo authentication with source system 2', () => {
      (authenticateType as jest.Mock).mockReturnValue('myinfo');
      (getUrl.getParameterByName as jest.Mock).mockImplementation(param => 
        param === 'auth' ? 'myinfo' : null
      );

      const result = RulesSSF(mockProps, baseStageInfo);
      
      expect(rulesUtils).toHaveBeenCalled();
      expect(result).toBeDefined();
    });

    it('should handle iBanking authentication', () => {
      const stageInfo = {
        ...baseStageInfo,
        applicants: {
          ...baseStageInfo.applicants,
          auth_mode_a_1: 'IX'
        }
      };

      const result = RulesSSF(mockProps, stageInfo);
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          nonEditable: expect.any(Array),
          hidden: expect.any(Array)
        })
      );
    });

    it('should handle manual authentication', () => {
      (authenticateType as jest.Mock).mockReturnValue('manual');
      
      const result = RulesSSF(mockProps, baseStageInfo);
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          modifyVisibility: [expect.arrayContaining(['date_of_birth', 'residency_status'])],
          hidden: [expect.arrayContaining([
            "ownership_status",
            "residential_address",
            "see_other_myInfo_details"
          ])]
        })
      );
    });
  });

  describe('Product Specific Rules', () => {
    it('should hide specific fields for TD products', () => {
      const stageInfo = {
        ...baseStageInfo,
        products: [
          { product_category: 'TD', product_type: '337' },
          { product_category: 'TD', product_type: '338' }
        ]
      };

      (authenticateType as jest.Mock).mockReturnValue('myinfo');
      
      const result = RulesSSF(mockProps, stageInfo);
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          hidden: [expect.arrayContaining([
            "no_of_accounts_rwb",
            "mode_of_operation",
            "pass_exp_dt"
          ])]
        })
      );
    });

    it('should show default editable fields for non-CA/SA products', () => {
      const stageInfo = {
        ...baseStageInfo,
        products: [
          { product_category: 'TD', product_type: '123' }
        ]
      };

      (authenticateType as jest.Mock).mockReturnValue('myinfo');
      
      RulesSSF(mockProps, stageInfo);
      
      expect(filterDisableFields).toHaveBeenCalledWith(
        expect.any(Array),
        expect.any(Array),
        ['email', 'mobile_number', 'account_currency_9']
      );
    });
  });

  describe('Field Visibility Rules', () => {
    it('should hide contact_preference_casa_etc and dsa_code for multiple applicants', () => {
      localStorage.setItem('applicantNo', '2');
      (authenticateType as jest.Mock).mockReturnValue('myinfo');
      
      const result = RulesSSF(mockProps, baseStageInfo);
      
      expect(rulesUtils).toHaveBeenCalledWith(
        expect.any(Array),
        expect.objectContaining({
          hidden: [expect.arrayContaining([
            "contact_preference_casa_etc",
            "dsa_code"
          ])]
        })
      );
    });

    it('should add missing fields to nonEditable list', () => {
      const stageInfo = {
        ...baseStageInfo,
        applicants: {
          ...baseStageInfo.applicants,
          mobile_number_a_1: undefined,
          email_a_1: undefined
        }
      };

      (authenticateType as jest.Mock).mockReturnValue('myinfo');
      
      RulesSSF(mockProps, stageInfo);
      
      expect(filterDisableFields).toHaveBeenCalledWith(
        expect.any(Array),
        expect.arrayContaining(['mobile_number', 'email', 'ownership_status']),
        expect.any(Array)
      );
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty products array', () => {
      const stageInfo = {
        ...baseStageInfo,
        products: []
      };

      const result = RulesSSF(mockProps, stageInfo);
      expect(result).toBeDefined();
    });

    it('should handle missing field_set_name', () => {
      const modifiedProps = [[{ fields: [] }]];
      const result = RulesSSF(modifiedProps, baseStageInfo);
      expect(result).toBeDefined();
    });

    it('should handle empty stageInfo', () => {
      const result = RulesSSF(mockProps, {} as any);
      expect(result).toBeDefined();
    });
  });
});
