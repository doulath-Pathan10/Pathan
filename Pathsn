import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { configureStore } from '@reduxjs/toolkit';
import DocumentUpload from './DocumentUpload';
import axios from 'axios';
import * as commonService from '../../../services/common-service';
import * as documentUtils from './document-upload.utils';
import trackEvents from '../../../services/track-events';

// Mock modules
jest.mock('axios');
jest.mock('../../../services/common-service');
jest.mock('./document-upload.utils');
jest.mock('../../../services/track-events');
jest.mock('../../../modules/dashboard/footer/footer', () => ({
  __esModule: true,
  default: ({ backHandler, documentFlag, uploadJourney }) => (
    <div data-testid="footer">
      <button onClick={backHandler} data-testid="back-button">Back</button>
    </div>
  )
}));
jest.mock('../popup-model/popup-model', () => ({
  __esModule: true,
  default: ({ children, displayPopup }) => displayPopup ? <div data-testid="popup">{children}</div> : null
}));
jest.mock('../model/model', () => ({
  __esModule: true,
  default: ({ name, handlebuttonClick }) => (
    <div data-testid="error-model">
      <span>{name}</span>
      <button onClick={handlebuttonClick} data-testid="error-close">Close</button>
    </div>
  )
}));

const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock store setup
const createMockStore = (initialState = {}) => {
  const defaultState = {
    documentUploadList: {
      responseDocuments: [{
        document_list: [{
          document_category: 'Identity Document',
          document_category_code: 'ID',
          min_options_req: 1,
          docCheck: 'N',
          isSlectedForUpload: 'N',
          document_options: [{
            document_types: [{
              document_type: 'NRIC',
              document_type_code: 'R0001',
              document_requested_stage: 'BD',
              uploaded_documents: null
            }]
          }]
        }],
        isSignatureDoc: false
      }]
    },
    stages: {
      stages: [{
        stageId: 'doc',
        stageInfo: {
          application: {
            channel_reference: 'TEST123',
            application_reference: 'APP123'
          },
          applicant_documents: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            min_options_req: 1,
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                document_requested_stage: 'BD'
              }]
            }]
          }],
          applicants: {},
          products: [{ product_category: 'CC' }]
        }
      }],
      journeyType: 'ETC',
      userInput: { applicants: {} },
      isDocumentUpload: false,
      isDocument: false
    },
    valueUpdate: {
      backNavigation: { nextStageId: null }
    },
    loader: { isFetching: false },
    urlparam: {}
  };

  return configureStore({
    reducer: {
      documentUploadList: (state = defaultState.documentUploadList) => state,
      stages: (state = defaultState.stages) => state,
      valueUpdate: (state = defaultState.valueUpdate) => state,
      loader: (state = defaultState.loader) => state,
      urlparam: (state = defaultState.urlparam) => state
    },
    preloadedState: { ...defaultState, ...initialState }
  });
};

const renderWithProviders = (component, initialState = {}) => {
  const store = createMockStore(initialState);
  return render(
    <Provider store={store}>
      <BrowserRouter>
        {component}
      </BrowserRouter>
    </Provider>
  );
};

describe('DocumentUpload Component', () => {
  const mockProps = {
    backHandler: jest.fn()
  };

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Mock environment variables
    process.env.REACT_APP_DOCUMENT_UPLOAD = '/upload';
    process.env.REACT_APP_RTOB_BASE_URL = 'https://api.test.com';
    process.env.REACT_APP_ENVIRONMENT = 'test';

    // Mock utility functions
    documentUtils.filterDocuments.mockReturnValue([{
      document_category: 'Identity Document',
      document_category_code: 'ID',
      min_options_req: 1,
      docCheck: 'N',
      isSlectedForUpload: 'N',
      document_options: [{
        document_types: [{
          document_type: 'NRIC',
          document_type_code: 'R0001',
          document_requested_stage: 'BD',
          uploaded_documents: null
        }]
      }]
    }]);

    documentUtils.fileValidation.mockReturnValue({ enableError: false });
    documentUtils.getDocumentMetaData.mockReturnValue({});
    documentUtils.documentClientContext.mockReturnValue({});
    documentUtils.setSuccessStatus.mockResolvedValue({});
    documentUtils.fileuploadSuccess.mockResolvedValue({ docId: 'test123' });
    documentUtils.validateMandatoryDoc.mockResolvedValue({});

    commonService.dispatchLoader.mockReturnValue({ type: 'MOCK_ACTION' });
    commonService.dispatchCtaLoader.mockReturnValue({ type: 'MOCK_ACTION' });
    commonService.documentSubmit.mockResolvedValue({ success: true });
    commonService.channelReference.mockResolvedValue({ data: { stage: { page_id: 'ad-2' } } });

    trackEvents.triggerAdobeEvent.mockImplementation(() => {});
  });

  test('renders document upload component', () => {
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    expect(screen.getByText(/Upload your identity document/i)).toBeInTheDocument();
    expect(screen.getByTestId('footer')).toBeInTheDocument();
  });

  test('displays document categories and options', () => {
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    expect(screen.getByText(/Upload your identity document/i)).toBeInTheDocument();
    expect(screen.getByText('NRIC')).toBeInTheDocument();
  });

  test('handles document selection via radio button', () => {
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    const radioButton = screen.getByRole('radio');
    fireEvent.click(radioButton);
    
    // Should update the document selection state
    expect(radioButton).toBeChecked();
  });

  test('shows upload button after document selection', () => {
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    const uploadButtons = screen.getAllByTestId('upload');
    expect(uploadButtons[0]).toBeInTheDocument();
  });

  test('handles upload button click when document is selected', () => {
    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            min_options_req: 1,
            docCheck: 'Y',
            isSlectedForUpload: 'N',
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                document_requested_stage: 'BD',
                uploaded_documents: { tempDocStore: { isSelected: 'Y' } }
              }]
            }]
          }],
          isSignatureDoc: false
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    const uploadButton = screen.getByTestId('upload');
    fireEvent.click(uploadButton);
    
    expect(trackEvents.triggerAdobeEvent).toHaveBeenCalledWith('ctaClick', 'Upload Document');
  });

  test('shows error when trying to upload without document selection', () => {
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    const uploadButton = screen.getByTestId('upload');
    fireEvent.click(uploadButton);
    
    // Should show error popup
    waitFor(() => {
      expect(screen.getByTestId('popup')).toBeInTheDocument();
      expect(screen.getByTestId('error-model')).toBeInTheDocument();
    });
  });

  test('handles file upload', async () => {
    const mockFile = new File(['test'], 'test.pdf', { type: 'application/pdf' });
    const mockResponse = { data: { docId: 'test123', status: 'Accepted' } };
    
    mockedAxios.create.mockReturnValue({
      post: jest.fn().mockResolvedValue(mockResponse)
    });

    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            min_options_req: 1,
            docCheck: 'Y',
            isSlectedForUpload: 'Y',
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                document_requested_stage: 'BD',
                uploaded_documents: [{ documentStatus: null }]
              }]
            }]
          }],
          isSignatureDoc: false
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    const fileInput = screen.getByRole('textbox', { hidden: true }) || 
                     document.querySelector('input[type="file"]');
    
    if (fileInput) {
      fireEvent.change(fileInput, { target: { files: [mockFile] } });
      
      await waitFor(() => {
        expect(documentUtils.fileValidation).toHaveBeenCalledWith([mockFile], expect.any(Object));
      });
    }
  });

  test('handles file validation errors', () => {
    documentUtils.fileValidation.mockReturnValue({
      enableError: true,
      errorType: 'invalidFile'
    });

    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            isSlectedForUpload: 'Y',
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                uploaded_documents: [{ documentStatus: null }]
              }]
            }]
          }]
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    const mockFile = new File(['test'], 'test.txt', { type: 'text/plain' });
    const fileInput = document.querySelector('input[type="file"]');
    
    if (fileInput) {
      fireEvent.change(fileInput, { target: { files: [mockFile] } });
      
      waitFor(() => {
        expect(screen.getByTestId('popup')).toBeInTheDocument();
      });
    }
  });

  test('displays upload progress', () => {
    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            isSlectedForUpload: 'Y',
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                uploaded_documents: [{
                  documentStatus: 'UPLOADING',
                  progress: 50
                }]
              }]
            }]
          }]
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    expect(screen.getByText(/Uploading in progress.../i)).toBeInTheDocument();
    expect(screen.getByText(/50%/)).toBeInTheDocument();
  });

  test('displays successful upload', () => {
    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            isSlectedForUpload: 'Y',
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                uploaded_documents: [{
                  documentStatus: 'Accepted',
                  docId: 'test123'
                }]
              }]
            }]
          }]
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    expect(screen.getByText(/File is successfully uploaded/i)).toBeInTheDocument();
  });

  test('handles file deletion', () => {
    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            isSlectedForUpload: 'Y',
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                uploaded_documents: [{
                  documentStatus: 'Accepted',
                  docId: 'test123'
                }]
              }]
            }]
          }]
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    const deleteButton = screen.getByClassName('upload-icon--success');
    if (deleteButton) {
      fireEvent.click(deleteButton);
      // Should remove the file from the list
    }
  });

  test('handles form submission with valid documents', async () => {
    documentUtils.validateMandatoryDoc.mockResolvedValue({});
    
    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            min_options_req: 1,
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                uploaded_documents: [{
                  documentStatus: 'Accepted',
                  docId: 'test123'
                }]
              }]
            }]
          }]
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    const form = screen.getByRole('form') || document.querySelector('form');
    if (form) {
      fireEvent.submit(form);
      
      await waitFor(() => {
        expect(commonService.documentSubmit).toHaveBeenCalled();
      });
    }
  });

  test('shows error for missing mandatory documents', async () => {
    documentUtils.validateMandatoryDoc.mockResolvedValue({ R0001: 1 });
    
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    const form = document.querySelector('form');
    if (form) {
      fireEvent.submit(form);
      
      await waitFor(() => {
        expect(screen.getByTestId('popup')).toBeInTheDocument();
        expect(screen.getByText('missingMandatoryDocument')).toBeInTheDocument();
      });
    }
  });

  test('handles back button click', () => {
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    const backButton = screen.getByTestId('back-button');
    fireEvent.click(backButton);
    
    expect(mockProps.backHandler).toHaveBeenCalled();
    expect(trackEvents.triggerAdobeEvent).toHaveBeenCalledWith('ctaClick', 'Back');
  });

  test('displays file format guidelines', () => {
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    expect(screen.getByText(/JPG, PNG, TIFF, and PDF formats/i)).toBeInTheDocument();
    expect(screen.getByText(/less than 10 MB/i)).toBeInTheDocument();
    expect(screen.getByText(/File is clear and visible to read/i)).toBeInTheDocument();
  });

  test('displays signature document specific guidelines', () => {
    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [],
          isSignatureDoc: true
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    expect(screen.getByText(/JPG and PNG formats only for Signature Specimen/i)).toBeInTheDocument();
    expect(screen.getByText(/I confirm that the electronic image of my signature/i)).toBeInTheDocument();
  });

  test('handles stage-specific document filtering for doc-2', () => {
    const initialState = {
      stages: {
        stages: [{
          stageId: 'doc-2',
          stageInfo: {
            application: {
              channel_reference: 'TEST123',
              application_reference: 'APP123'
            },
            applicants: { application_sourcing_a_1: '2' },
            applicant_documents: [],
            products: [{ product_category: 'CC' }]
          }
        }],
        journeyType: 'ETC',
        userInput: { applicants: {} }
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    expect(documentUtils.filterDocuments).toHaveBeenCalled();
  });

  test('handles error popup close', async () => {
    documentUtils.validateMandatoryDoc.mockResolvedValue({ R0001: 1 });
    
    renderWithProviders(<DocumentUpload {...mockProps} />);
    
    const form = document.querySelector('form');
    if (form) {
      fireEvent.submit(form);
      
      await waitFor(() => {
        expect(screen.getByTestId('popup')).toBeInTheDocument();
      });

      const closeButton = screen.getByTestId('error-close');
      fireEvent.click(closeButton);
      
      // Popup should be closed and error state reset
    }
  });

  test('handles add document functionality', () => {
    const initialState = {
      documentUploadList: {
        responseDocuments: [{
          document_list: [{
            document_category: 'Identity Document',
            document_category_code: 'ID',
            isSlectedForUpload: 'Y',
            document_options: [{
              document_types: [{
                document_type: 'NRIC',
                document_type_code: 'R0001',
                uploaded_documents: [{
                  documentStatus: 'Accepted',
                  docId: 'test123'
                }]
              }]
            }]
          }]
        }]
      }
    };

    renderWithProviders(<DocumentUpload {...mockProps} />, initialState);
    
    // Should show add document button after successful upload
    const uploadButtons = screen.getAllByTestId('upload');
    if (uploadButtons.length > 1) {
      fireEvent.click(uploadButtons[uploadButtons.length - 1]);
      // Should add new upload slot
    }
  });
});
