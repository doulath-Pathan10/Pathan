import Rules_ad_1 from './Rules_ad_1';
import rulesUtils from './rules.utils';

// Mock dependencies
jest.mock('./rules.utils');
jest.mock('../../utils/store/store', () => ({
  store: {}
}));

// Mock localStorage
const mockLocalStorage = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage
});

describe('Rules_ad_1', () => {
  let mockProps;
  let mockStageInfo;
  let mockRulesUtils;

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();
    mockRulesUtils = rulesUtils as jest.MockedFunction<typeof rulesUtils>;
    mockRulesUtils.mockReturnValue({ test: 'result' });

    // Default mock props structure
    mockProps = [
      [
        {
          field_set_name: "Additional Details",
          fields: [
            { logical_field_name: "field1", component_type: "Text" },
            { logical_field_name: "field2", component_type: "Text" }
          ]
        },
        { field_set_name: "Other" },
        { field_set_name: "Another" },
        {
          field_set_name: "Additional Details Template",
          fields: [
            { logical_field_name: "template_field1", component_type: "Text", mandatory: "false" },
            { logical_field_name: "template_field2", component_type: "Text", mandatory: "false" }
          ]
        },
        {
          field_set_name: "Banking Services",
          fields: [
            { logical_field_name: "debit_card_request_rwb", component_type: "Text" },
            { logical_field_name: "issuance_type", component_type: "Text" },
            { logical_field_name: "embossed_dc_name_rwb", component_type: "Text" },
            { logical_field_name: "existing_account_no_dc", component_type: "Text" },
            { logical_field_name: "cheque_book_request_rwb", component_type: "Text" },
            { logical_field_name: "other_banking_field", component_type: "Text" }
          ]
        },
        {
          field_set_name: "Time Deposit Details",
          fields: [
            { logical_field_name: "td_product_currency_value", component_type: "Text" },
            { logical_field_name: "td_depoist_amount", component_type: "Text" },
            { logical_field_name: "td_term_type", component_type: "Text" }
          ]
        }
      ]
    ];

    // Default mock stage info
    mockStageInfo = {
      applicants: {
        no_of_accounts_rwb_a_1: 1
      },
      products: [
        {
          product_category: 'CA',
          product_type: '307',
          product_category_name: 'Current Account',
          name: 'Basic CA'
        }
      ]
    };
  });

  describe('Basic functionality', () => {
    test('should handle single product with basic configuration', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        {
          product_category_name: 'Current Account',
          name: 'Basic CA'
        }
      ]));

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ test: 'result' });
    });

    test('should handle empty localStorage products', () => {
      mockLocalStorage.getItem.mockReturnValue('[]');

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ test: 'result' });
    });

    test('should handle null localStorage', () => {
      mockLocalStorage.getItem.mockReturnValue(null);

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ test: 'result' });
    });
  });

  describe('Multiple products handling', () => {
    test('should handle multiple products with product_type 307 and 318', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        {
          product_category_name: 'Current Account',
          name: 'Basic CA'
        },
        {
          product_category_name: 'Savings Account',
          name: 'Basic SA'
        }
      ]));

      mockStageInfo.products = [
        { product_type: '307' },
        { product_type: '318' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
      expect(result).toEqual({ test: 'result' });
    });

    test('should handle multiple products with product_type 339 and 318', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        {
          product_category_name: 'Current Account',
          name: 'Basic CA'
        },
        {
          product_category_name: 'Savings Account',
          name: 'Basic SA'
        }
      ]));

      mockStageInfo.products = [
        { product_type: '339' },
        { product_type: '318' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle multiple products with product_type 504 and 516', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        {
          product_category_name: 'Current Account',
          name: 'Basic CA'
        },
        {
          product_category_name: 'Savings Account',
          name: 'Basic SA'
        }
      ]));

      mockStageInfo.products = [
        { product_type: '504' },
        { product_type: '516' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle multiple products with product_type 504 and 507', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        {
          product_category_name: 'Current Account',
          name: 'Basic CA'
        },
        {
          product_category_name: 'Savings Account',
          name: 'Basic SA'
        }
      ]));

      mockStageInfo.products = [
        { product_type: '504' },
        { product_type: '507' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle multiple products with other combinations', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        {
          product_category_name: 'Current Account',
          name: 'Basic CA'
        },
        {
          product_category_name: 'Savings Account',
          name: 'Basic SA'
        }
      ]));

      mockStageInfo.products = [
        { product_type: '999' }, // Non-matching type
        { product_type: '888' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });

  describe('Repeat count handling', () => {
    test('should handle repeat count with product_type 310', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockStageInfo.applicants.no_of_accounts_rwb_a_1 = 3;
      mockStageInfo.products = [{ product_type: '310' }];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle repeat count with product_type 307', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockStageInfo.applicants.no_of_accounts_rwb_a_1 = 2;
      mockStageInfo.products = [{ product_type: '307' }];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle repeat count with product_type 324', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockStageInfo.applicants.no_of_accounts_rwb_a_1 = 2;
      mockStageInfo.products = [{ product_type: '324' }];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle undefined repeat count', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockStageInfo.applicants.no_of_accounts_rwb_a_1 = undefined;
      mockStageInfo.products = [{ product_type: '310' }];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });

  describe('Multiple products combinations for second loop', () => {
    test('should handle product_type 337 and 310 combination', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '337' },
        { product_type: '310' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle product_type 337 and 329 combination', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '337' },
        { product_type: '329' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle product_type 307 and 329 combination', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '307' },
        { product_type: '329' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle product_type 337 and 339 combination', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '337' },
        { product_type: '339' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle product_type 514 and 504 combination', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '514' },
        { product_type: '504' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle product_type 514 and 507 combination', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '514' },
        { product_type: '507' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle product_type 504 and 507 combination in second loop', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '504' },
        { product_type: '507' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle product_type 516 and 507 combination in second loop', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '516' },
        { product_type: '507' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle other product combinations in second loop', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '999' },
        { product_type: '888' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });

  describe('Time Deposit (TD) handling', () => {
    test('should handle single TD product', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'TD', name: 'Time Deposit' }
      ]));

      mockStageInfo.products = [
        { product_category: 'TD', product_type: '501' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle multiple products with TD', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Current' },
        { product_category_name: 'TD', name: 'Time Deposit' }
      ]));

      mockStageInfo.products = [
        { product_category: 'CA', product_type: '307' },
        { product_category: 'TD', product_type: '501' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle multiple products with TD and product_type 337', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Current' },
        { product_category_name: 'TD', name: 'Time Deposit' }
      ]));

      mockStageInfo.products = [
        { product_category: 'CA', product_type: '337' },
        { product_category: 'TD', product_type: '501' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle TD products with component type conversion', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'TD', name: 'Time Deposit' }
      ]));

      mockStageInfo.products = [
        { product_category: 'TD', product_type: '501' }
      ];

      // Ensure the TD field exists in the mock
      mockProps[0].push({
        field_set_name: "Time Deposit Details",
        fields: [
          { logical_field_name: "td_product_currency_value", component_type: "Text" },
          { logical_field_name: "other_td_field", component_type: "SelectionBox" }
        ]
      });

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });

  describe('CA product type specific handling', () => {
    test('should handle CA product with product_type 317', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Current Account' }
      ]));

      mockStageInfo.products = [
        { product_category: 'CA', product_type: '317' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle CA product with product_type 314', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Current Account' }
      ]));

      mockStageInfo.products = [
        { product_category: 'CA', product_type: '314' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle CA product with other product types', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Current Account' }
      ]));

      mockStageInfo.products = [
        { product_category: 'CA', product_type: '999' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });

  describe('Edge cases and missing data', () => {
    test('should handle missing applicants object', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockStageInfo.applicants = {};

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle missing products array', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockStageInfo.products = [];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle empty filteredFields', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      // Mock props with no "Additional Details" field set
      mockProps = [
        [
          { field_set_name: "Other Details" },
          { field_set_name: "Banking Services", fields: [] }
        ]
      ];

      mockStageInfo.products = [{ product_type: '307' }];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle missing field_set_name in filteredFields', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockProps[0][0] = { field_set_name: "Different Name" };

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle complex scenario with multiple conditions', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' },
        { product_category_name: 'TD', name: 'Term' }
      ]));

      mockStageInfo = {
        applicants: { no_of_accounts_rwb_a_1: 3 },
        products: [
          { product_category: 'CA', product_type: '310' },
          { product_category: 'SA', product_type: '337' },
          { product_category: 'TD', product_type: '501' }
        ]
      };

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });

  describe('TD Products filtering', () => {
    test('should handle TD products filter correctly', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'TD', name: 'Term Deposit' }
      ]));

      mockStageInfo.products = [
        { product_category: 'CA', product_type: '307' },
        { product_category: 'TD', product_type: '501' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });

    test('should handle empty TD products filter', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' }
      ]));

      mockStageInfo.products = [
        { product_category: 'CA', product_type: '307' }
      ];

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });

  describe('Field filtering logic', () => {
    test('should handle banking services field filtering with all excluded fields', () => {
      mockLocalStorage.getItem.mockReturnValue(JSON.stringify([
        { product_category_name: 'CA', name: 'Basic' },
        { product_category_name: 'SA', name: 'Savings' }
      ]));

      mockStageInfo.products = [
        { product_type: '307' },
        { product_type: '318' }
      ];

      // Add all fields that should be filtered out
      mockProps[0][4] = {
        field_set_name: "Banking Services",
        fields: [
          { logical_field_name: "debit_card_request_rwb", component_type: "Text" },
          { logical_field_name: "issuance_type", component_type: "Text" },
          { logical_field_name: "embossed_dc_name_rwb", component_type: "Text" },
          { logical_field_name: "existing_account_no_dc", component_type: "Text" },
          { logical_field_name: "cheque_book_request_rwb", component_type: "Text" },
          { logical_field_name: "allowed_field", component_type: "Text" }
        ]
      };

      const result = Rules_ad_1(mockProps, mockStageInfo);

      expect(mockRulesUtils).toHaveBeenCalled();
    });
  });
});
