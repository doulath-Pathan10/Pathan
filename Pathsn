import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { configureStore } from '@reduxjs/toolkit';
import Dashboard from './Dashboard';
import * as commonService from '../../services/common-service';
import * as changeUtils from '../../utils/common/change.utils';

// Mock the components
jest.mock('./header/header', () => {
  return function MockHeader() {
    return <div data-testid="header">Header Component</div>;
  };
});

jest.mock('./fields/fields', () => {
  return function MockFields() {
    return <div data-testid="fields">Fields Component</div>;
  };
});

jest.mock('../../shared/components/myinfo-singpass-login-modal/myinfo-singpass-login', () => {
  return function MockMyinfoSingpassLogin() {
    return <div data-testid="myinfo-login">MyInfo Login Component</div>;
  };
});

jest.mock('../../shared/components/popup-model/popup-model', () => {
  return function MockPopupModel({ children, displayPopup }) {
    return displayPopup ? <div data-testid="popup-model">{children}</div> : null;
  };
});

jest.mock('../../shared/components/model/model', () => {
  return function MockModel({ name, handlebuttonClick }) {
    return (
      <div data-testid="model">
        <span data-testid="model-name">{name}</span>
        <button data-testid="model-button" onClick={handlebuttonClick}>
          Close
        </button>
      </div>
    );
  };
});

// Mock the services
jest.mock('../../services/common-service', () => ({
  dispatchLoader: jest.fn(),
  getClientInfo: jest.fn(),
}));

// Mock the utils
jest.mock('../../utils/common/change.utils', () => ({
  authenticateType: jest.fn(),
  getUrl: {
    getLoader: jest.fn(() => ({ cta: { cta: false } })),
    getParameterByName: jest.fn(),
  },
}));

// Mock the store
jest.mock('../../utils/store/store', () => ({
  store: {
    getState: jest.fn(() => ({
      urlParam: { validUrl: true },
    })),
  },
}));

// Mock react-router-dom
const mockNavigate = jest.fn();
const mockLocation = {
  pathname: '/dashboard',
  search: '',
  hash: '',
  state: null,
  key: 'test',
};

jest.mock('react-router-dom', () => ({
  ...jest.requireActual('react-router-dom'),
  useNavigate: () => mockNavigate,
  useLocation: () => mockLocation,
}));

// Create mock store
const createMockStore = (initialState = {}) => {
  const defaultState = {
    stages: {
      stages: [],
      otpOpen: false,
      otpResume: false,
    },
    urlParam: {
      myInfo: false,
      validUrl: true,
    },
    referralcode: {
      referId: null,
    },
    ...initialState,
  };

  return configureStore({
    reducer: {
      stages: (state = defaultState.stages) => state,
      urlParam: (state = defaultState.urlParam) => state,
      referralcode: (state = defaultState.referralcode) => state,
    },
    preloadedState: defaultState,
  });
};

// Helper function to render component with providers
const renderWithProviders = (component, { initialState = {} } = {}) => {
  const store = createMockStore(initialState);
  
  return render(
    <Provider store={store}>
      <BrowserRouter>
        {component}
      </BrowserRouter>
    </Provider>
  );
};

describe('Dashboard Component', () => {
  let mockDispatch;

  beforeEach(() => {
    mockDispatch = jest.fn();
    jest.clearAllMocks();
    
    // Reset window size
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 1024,
    });
    
    // Mock useDispatch
    jest.doMock('react-redux', () => ({
      ...jest.requireActual('react-redux'),
      useDispatch: () => mockDispatch,
    }));
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  test('renders dashboard with header when valid URL and stages exist', async () => {
    const mockStages = [
      {
        stageId: 'test-stage',
        stageInfo: {
          application: {
            refer: false,
            referId: null,
          },
        },
      },
    ];

    commonService.getClientInfo.mockResolvedValue(true);
    commonService.dispatchLoader.mockReturnValue({ type: 'DISPATCH_LOADER' });

    renderWithProviders(<Dashboard />, {
      initialState: {
        stages: { stages: mockStages, otpOpen: false, otpResume: false },
        urlParam: { myInfo: false, validUrl: true },
      },
    });

    await waitFor(() => {
      expect(screen.getByTestId('header')).toBeInTheDocument();
    });
  });

  test('displays popup when URL is invalid', async () => {
    const mockStore = createMockStore({
      urlParam: { validUrl: false, myInfo: false },
    });

    // Mock store.getState to return invalid URL
    require('../../utils/store/store').store.getState.mockReturnValue({
      urlParam: { validUrl: false },
    });

    commonService.dispatchLoader.mockReturnValue({ type: 'DISPATCH_LOADER' });

    render(
      <Provider store={mockStore}>
        <BrowserRouter>
          <Dashboard />
        </BrowserRouter>
      </Provider>
    );

    await waitFor(() => {
      expect(screen.getByTestId('popup-model')).toBeInTheDocument();
      expect(screen.getByTestId('model')).toBeInTheDocument();
      expect(screen.getByTestId('model-name')).toHaveTextContent('globalError');
    });
  });

  test('displays MyInfo login popup when myInfo is true', async () => {
    renderWithProviders(<Dashboard />, {
      initialState: {
        urlParam: { myInfo: true, validUrl: true },
      },
    });

    await waitFor(() => {
      expect(screen.getByTestId('popup-model')).toBeInTheDocument();
      expect(screen.getByTestId('myinfo-login')).toBeInTheDocument();
    });
  });

  test('displays confirmation popup when authenticate type is myinfo', async () => {
    changeUtils.authenticateType.mockReturnValue('myinfo');
    commonService.getClientInfo.mockResolvedValue(true);

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(screen.getByTestId('model')).toBeInTheDocument();
      expect(screen.getByTestId('model-name')).toHaveTextContent('confirmationPopup');
    });
  });

  test('navigates to super-short-form when client info is successful and no confirmation popup', async () => {
    changeUtils.authenticateType.mockReturnValue('other');
    commonService.getClientInfo.mockResolvedValue(true);
    commonService.dispatchLoader.mockReturnValue({ type: 'DISPATCH_LOADER' });

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('sg/super-short-form');
    });
  });

  test('renders fields component when fieldsComponent is true and stages exist', async () => {
    const mockStages = [
      {
        stageId: 'test-stage',
        stageInfo: {
          application: {
            refer: false,
            referId: null,
          },
        },
      },
    ];

    changeUtils.authenticateType.mockReturnValue('other');
    commonService.getClientInfo.mockResolvedValue(true);
    commonService.dispatchLoader.mockReturnValue({ type: 'DISPATCH_LOADER' });

    renderWithProviders(<Dashboard />, {
      initialState: {
        stages: { stages: mockStages, otpOpen: false, otpResume: false },
      },
    });

    await waitFor(() => {
      expect(screen.getByTestId('fields')).toBeInTheDocument();
    });
  });

  test('applies pointer-none class when pointer is true', async () => {
    const mockStages = [
      {
        stageId: 'test-stage',
        stageInfo: {
          application: {
            refer: false,
            referId: null,
          },
        },
      },
    ];

    // Mock getLoader to return cta: true
    changeUtils.getUrl.getLoader.mockReturnValue({ cta: { cta: true } });
    changeUtils.authenticateType.mockReturnValue('other');
    commonService.getClientInfo.mockResolvedValue(true);

    renderWithProviders(<Dashboard />, {
      initialState: {
        stages: { stages: mockStages, otpOpen: false, otpResume: false },
      },
    });

    await waitFor(() => {
      const appBody = document.querySelector('.app__body');
      expect(appBody).toHaveClass('pointer-none');
    });
  });

  test('handles window resize events', async () => {
    const mockStages = [
      {
        stageId: 'test-stage',
        stageInfo: {
          application: {
            refer: false,
            referId: null,
          },
        },
      },
    ];

    changeUtils.authenticateType.mockReturnValue('other');
    commonService.getClientInfo.mockResolvedValue(true);

    renderWithProviders(<Dashboard />, {
      initialState: {
        stages: { stages: mockStages, otpOpen: false, otpResume: false },
      },
    });

    // Simulate window resize to mobile view
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 500,
    });

    fireEvent(window, new Event('resize'));

    await waitFor(() => {
      expect(window.innerWidth).toBe(500);
    });
  });

  test('handles confirmation popup back button click', async () => {
    changeUtils.authenticateType.mockReturnValue('myinfo');
    commonService.getClientInfo.mockResolvedValue(true);

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(screen.getByTestId('model-button')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByTestId('model-button'));

    await waitFor(() => {
      expect(screen.queryByTestId('model')).not.toBeInTheDocument();
    });
  });

  test('does not render main content when confirmation popup is open', async () => {
    changeUtils.authenticateType.mockReturnValue('myinfo');
    commonService.getClientInfo.mockResolvedValue(true);

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(screen.getByTestId('model')).toBeInTheDocument();
      expect(screen.queryByTestId('header')).not.toBeInTheDocument();
    });
  });

  test('does not render main content when OTP is open', async () => {
    const mockStages = [
      {
        stageId: 'test-stage',
        stageInfo: {
          application: {
            refer: false,
            referId: null,
          },
        },
      },
    ];

    renderWithProviders(<Dashboard />, {
      initialState: {
        stages: { stages: mockStages, otpOpen: true, otpResume: false },
      },
    });

    expect(screen.queryByTestId('header')).not.toBeInTheDocument();
    expect(screen.queryByTestId('fields')).not.toBeInTheDocument();
  });

  test('dispatches loader actions on component mount', async () => {
    commonService.dispatchLoader.mockReturnValue({ type: 'DISPATCH_LOADER' });
    commonService.getClientInfo.mockResolvedValue(true);

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(commonService.dispatchLoader).toHaveBeenCalledWith(true);
    });
  });

  test('handles getClientInfo rejection', async () => {
    commonService.getClientInfo.mockRejectedValue(new Error('Network error'));
    commonService.dispatchLoader.mockReturnValue({ type: 'DISPATCH_LOADER' });

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(commonService.getClientInfo).toHaveBeenCalled();
    });
  });

  test('sets margin top based on header height', async () => {
    const mockStages = [
      {
        stageId: 'test-stage',
        stageInfo: {
          application: {
            refer: false,
            referId: null,
          },
        },
      },
    ];

    changeUtils.authenticateType.mockReturnValue('other');
    commonService.getClientInfo.mockResolvedValue(true);

    renderWithProviders(<Dashboard />, {
      initialState: {
        stages: { stages: mockStages, otpOpen: false, otpResume: false },
      },
    });

    await waitFor(() => {
      const appBody = document.querySelector('.app__body');
      expect(appBody).toBeInTheDocument();
    });
  });

  test('cleans up event listeners on unmount', async () => {
    const removeEventListenerSpy = jest.spyOn(window, 'removeEventListener');
    
    const { unmount } = renderWithProviders(<Dashboard />);
    
    unmount();
    
    expect(removeEventListenerSpy).toHaveBeenCalledWith('resize', expect.any(Function));
  });
});
