// stageUtils.test.js
import {
  stageFields,
  fieldGroupingFunc,
  userInputPayload,
  residentialAddress,
  submitRequest,
  compareStageRequest
} from './stageUtils';
import { store } from '../../../utils/store/store';
import { CONSTANTS } from '../../../utils/common/constants';
import { authenticateType, FindIndex } from '../../../utils/common/change.utils';

// Mock dependencies
jest.mock('../../../utils/store/store');
jest.mock('../../../utils/common/change.utils');

// Mock rules modules
jest.mock('../../rules/rules_bd-1', () => jest.fn());
jest.mock('../../rules/rules_bd-2', () => jest.fn());
jest.mock('../../rules/rules_ssf-1', () => jest.fn());
jest.mock('../../rules/rules_ssf-2', () => jest.fn());
jest.mock('../../rules/rules_ad-1', () => jest.fn());
jest.mock('../../rules/rules_ad-2', () => jest.fn());
jest.mock('../../rules/rules_acd', () => jest.fn());
jest.mock('../../rules/rules_ld-1', () => jest.fn());
jest.mock('../../rules/rules_bd-3', () => jest.fn());

// Mock sessionStorage
const sessionStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn()
};
global.sessionStorage = sessionStorageMock;

beforeEach(() => {
  jest.clearAllMocks();
  
  // Default mock implementations
  authenticateType.mockReturnValue('manual');
  FindIndex.mockImplementation((obj, stageId) => {
    if (stageId === 'ssf-1') return 0;
    if (stageId === 'ssf-2') return 1;
    return -1;
  });
  
  sessionStorage.getItem.mockImplementation((key) => 
    key === 'currentStage' ? '1' : null
  );
});
describe('stageFields', () => {
  const mockStageSelector = [{
    stageId: 'ssf-1',
    stageInfo: {
      fieldmetadata: {
        data: {
          stages: [
            { 
              stageId: 'ssf-1', 
              fields: [
                { field_set_name: 'Personal Info', logical_field_name: 'name', component_type: 'Text' },
                { field_set_name: 'Address', logical_field_name: 'address', component_type: 'Text' }
              ] 
            },
            { 
              stageId: 'ssf-2', 
              fields: [
                { field_set_name: 'Additional Info', logical_field_name: 'occupation', component_type: 'Text' }
              ] 
            }
          ]
        }
      },
      applicants: {}
    }
  }];

  it('should return fields for ssf-1 stage', () => {
    const result = stageFields(mockStageSelector, 'ssf-1');
    
    expect(result).toHaveProperty('fields');
    expect(FindIndex).toHaveBeenCalled();
  });

  it('should handle myinfo flow differently', () => {
    authenticateType.mockReturnValue('myinfo');
    const result = stageFields(mockStageSelector, 'ssf-1');
    
    expect(result).toHaveProperty('fields');
    expect(FindIndex).toHaveBeenCalled();
  });

  it('should handle ibanking flow differently', () => {
    authenticateType.mockReturnValue('ibanking');
    const result = stageFields(mockStageSelector, 'ssf-1');
    
    expect(result).toHaveProperty('fields');
    expect(FindIndex).toHaveBeenCalled();
  });

  it('should handle multiple applicants', () => {
    sessionStorage.getItem.mockReturnValue('2'); // currentStage = 2
    const result = stageFields(mockStageSelector, 'ssf-1');
    
    expect(result).toHaveProperty('fields');
  });

  it('should return empty fields when no stage data', () => {
    const result = stageFields([], 'ssf-1');
    expect(result.fields).toBeUndefined();
  });

  it('should apply different rules for different stages', () => {
    const stages = ['bd-1', 'bd-2', 'bd-3', 'ad-1', 'ad-2', 'ACD', 'ld-1'];
    
    stages.forEach(stage => {
      const result = stageFields(mockStageSelector, stage);
      expect(result).toHaveProperty('fields');
    });
  });
});
describe('fieldGroupingFunc', () => {
  it('should add new field group when not exists', () => {
    const prev = [];
    const items = { logical_field_name: 'test', component_type: 'Text' };
    
    fieldGroupingFunc(-1, prev, 'Test Group', items);
    
    expect(prev).toHaveLength(1);
    expect(prev[0].field_set_name).toBe('Test Group');
    expect(prev[0].fields).toContainEqual(items);
  });

  it('should append to existing field group', () => {
    const prev = [{ field_set_name: 'Test Group', fields: [] }];
    const items = { logical_field_name: 'test', component_type: 'Text' };
    
    fieldGroupingFunc(0, prev, 'Test Group', items);
    
    expect(prev).toHaveLength(1);
    expect(prev[0].fields).toContainEqual(items);
  });
});
describe('userInputPayload', () => {
  const mockDispatch = jest.fn();
  const mockApplicantsSelector = { name_a_1: 'John Doe' };
  const mockStageSelector = [{
    stageId: 'ssf-1',
    stageInfo: {
      applicants: { name_a_1: '' },
      fieldmetadata: { data: { stages: [] } }
    }
  }];

  it('should dispatch updated stage fields', async () => {
    await userInputPayload(mockApplicantsSelector, mockStageSelector)(mockDispatch);
    
    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'stages/updateStageFields',
        payload: expect.objectContaining({
          stageInfo: expect.objectContaining({
            applicants: expect.objectContaining({
              name_a_1: 'John Doe'
            })
          })
        })
      })
    );
  });

  it('should handle otherMyInfo parameter', async () => {
    await userInputPayload(mockApplicantsSelector, mockStageSelector, 'otherInfo')(mockDispatch);
    
    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'stages/updateStageFields',
        payload: expect.objectContaining({
          stageId: 'otherInfo'
        })
      })
    );
  });
});
describe('residentialAddress', () => {
  const mockStageSelector = [{
    stageInfo: {
      applicants: {
        block_a_1: '123',
        building_name_a_1: 'Tower A',
        street_name_a_1: 'Main Street',
        unit_no_a_1: '10-01',
        postal_code_a_1: '123456'
      }
    }
  }];

  it('should return formatted address with all components', () => {
    const result = residentialAddress(mockStageSelector);
    expect(result).toBe('123,Tower A,Main Street,10-01,123456');
  });

  it('should handle missing optional components', () => {
    const modifiedSelector = JSON.parse(JSON.stringify(mockStageSelector));
    delete modifiedSelector[0].stageInfo.applicants.building_name_a_1;
    delete modifiedSelector[0].stageInfo.applicants.unit_no_a_1;
    
    const result = residentialAddress(modifiedSelector);
    expect(result).toBe('123,Main Street,123456');
  });

  it('should return null when required fields are missing', () => {
    const modifiedSelector = JSON.parse(JSON.stringify(mockStageSelector));
    delete modifiedSelector[0].stageInfo.applicants.block_a_1;
    
    const result = residentialAddress(modifiedSelector);
    expect(result).toBeNull();
  });
});
describe('submitRequest', () => {
  const mockDispatch = jest.fn();
  const mockApplicantsSelector = { name_a_1: 'John Doe' };
  const mockStageSelector = {
    stageId: 'ssf-1',
    stageInfo: {
      fieldmetadata: {
        data: {
          stages: [
            { 
              stageId: 'ssf-1', 
              fields: [
                { logical_field_name: 'name', component_type: 'Text' }
              ] 
            }
          ]
        }
      },
      applicants: { name_a_1: '' },
      products: [{ product_type: 'CC' }]
    }
  };
  const mockStageSelectorThankYou = [mockStageSelector];
  const mockValueSelector = { 
    backNavigation: { formChange: null, nextStageId: null } 
  };
  const mockLovSelector = { lov: [] };
  const mockUserInputSelector = { applicants: {} };
  const mockErrorSelector = { retry: false };

  beforeEach(() => {
    // Mock store.getState
    store.getState.mockReturnValue({
      stages: {
        stages: [mockStageSelector]
      }
    });
  });

  it('should make preserve request when isPreserveCall is true', async () => {
    const result = await submitRequest(
      mockApplicantsSelector,
      mockStageSelector,
      mockStageSelectorThankYou,
      mockValueSelector,
      'ETC',
      mockLovSelector,
      mockUserInputSelector,
      mockErrorSelector,
      false,
      true // isPreserveCall
    )(mockDispatch);
    
    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function)); // preserveRequest
  });

  it('should handle bd-1 stage differently (skip API call)', async () => {
    const modifiedStageSelector = {
      ...mockStageSelector,
      stageId: 'bd-1'
    };
    
    const result = await submitRequest(
      mockApplicantsSelector,
      modifiedStageSelector,
      mockStageSelectorThankYou,
      mockValueSelector,
      'ETC',
      mockLovSelector,
      mockUserInputSelector,
      mockErrorSelector,
      false
    )(mockDispatch);
    
    expect(result).toBe('bd-2'); // Next stage after bd-1
    expect(mockDispatch).not.toHaveBeenCalledWith(expect.any(Function)); // No API call
  });

  it('should make post request when form has changes', async () => {
    const modifiedUserInputSelector = {
      applicants: { name_a_1: 'New Name' }
    };
    
    const result = await submitRequest(
      mockApplicantsSelector,
      mockStageSelector,
      mockStageSelectorThankYou,
      mockValueSelector,
      'ETC',
      mockLovSelector,
      modifiedUserInputSelector,
      mockErrorSelector,
      false
    )(mockDispatch);
    
    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function)); // postRequest
  });

  it('should handle retry scenario', async () => {
    const modifiedErrorSelector = { retry: true };
    
    const result = await submitRequest(
      mockApplicantsSelector,
      mockStageSelector,
      mockStageSelectorThankYou,
      mockValueSelector,
      'ETC',
      mockLovSelector,
      mockUserInputSelector,
      modifiedErrorSelector,
      false
    )(mockDispatch);
    
    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'error/getRetryStatus',
        payload: false
      })
    );
    expect(mockDispatch).toHaveBeenCalledWith(expect.any(Function)); // postRequest
  });
});
describe('compareStageRequest', () => {
  it('should return true when no changes', () => {
    const stageApplicants = { name_a_1: 'John', age_a_1: '30' };
    const userInput = { name_a_1: 'John', age_a_1: '30' };
    
    const result = compareStageRequest(stageApplicants, userInput);
    expect(result).toBe(true);
  });

  it('should return false when changes exist', () => {
    const stageApplicants = { name_a_1: 'John', age_a_1: '30' };
    const userInput = { name_a_1: 'Jane', age_a_1: '30' };
    
    const result = compareStageRequest(stageApplicants, userInput);
    expect(result).toBe(false);
  });

  it('should handle empty objects', () => {
    const result = compareStageRequest({}, {});
    expect(result).toBe(true);
  });
});
