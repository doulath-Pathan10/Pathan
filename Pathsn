import Rules_ad_1 from './Rules_ad_1';
import rulesUtils from './rules.utils';

// Mock dependencies
jest.mock('./rules.utils', () => jest.fn(() => ({})));

describe('Rules_ad_1', () => {
  const mockProps = [
    [
      {
        field_set_name: 'Basic Information',
        fields: [{ logical_field_name: 'basic_field' }]
      },
      {
        field_set_name: 'Additional Details',
        fields: [
          { logical_field_name: 'Initial_deposit_rwb' },
          { logical_field_name: 'reason_for_account_rwb' },
          { logical_field_name: 'source_of_fund_rwb' }
        ]
      },
      {
        field_set_name: 'Banking Services',
        fields: [
          { logical_field_name: 'debit_card_request_rwb' },
          { logical_field_name: 'cheque_book_request_rwb' },
          { logical_field_name: 'embossed_dc_name_rwb' },
          { logical_field_name: 'existing_account_no_dc' },
          { logical_field_name: 'issuance_type' }
        ]
      },
      {
        field_set_name: 'Time Deposit Details',
        fields: [
          { 
            logical_field_name: 'td_product_currency_value',
            component_type: 'Text'
          },
          { logical_field_name: 'td_depoist_amount' }
        ]
      },
      {
        field_set_name: '   ',
        fields: [
          { 
            logical_field_name: 'product_field',
            sub_product_code: ['prod1']
          }
        ]
      }
    ]
  ];

  const createStageInfo = (overrides = {}) => ({
    products: [
      { 
        product_type: 'prod1', 
        product_category: 'CA',
        product_category_name: 'Current Account', 
        name: 'Premium Account'
      }
    ],
    applicants: {
      no_of_accounts_rwb_a_1: 1
    },
    ...overrides
  });

  beforeEach(() => {
    jest.clearAllMocks();
    localStorage.clear();
    localStorage.setItem('products', JSON.stringify([
      { 
        product_type: 'prod1', 
        product_category_name: 'Current Account', 
        name: 'Premium Account'
      }
    ]));
  });

  describe('Field Grouping Logic', () => {
    it('should group Additional Details fields with product name', () => {
      const stageInfo = createStageInfo();
      const result = Rules_ad_1(mockProps, stageInfo);
      
      const [filteredFields] = (rulesUtils as jest.Mock).mock.calls[0];
      expect(filteredFields[0][0].field_set_name).toMatch(/Current Account - Premium Account Additional Details/);
    });

    it('should group Banking Services fields with product name', () => {
      const stageInfo = createStageInfo();
      const result = Rules_ad_1(mockProps, stageInfo);
      
      const [filteredFields] = (rulesUtils as jest.Mock).mock.calls[0];
      expect(filteredFields[0][1].field_set_name).toMatch(/Banking Services/);
    });

    it('should handle multiple products', () => {
      const stageInfo = createStageInfo({
        products: [
          { product_type: 'prod1', product_category_name: 'Account1', name: 'Product1' },
          { product_type: 'prod2', product_category_name: 'Account2', name: 'Product2' }
        ]
      });
      localStorage.setItem('products', JSON.stringify([
        { product_type: 'prod1', product_category_name: 'Account1', name: 'Product1' },
        { product_type: 'prod2', product_category_name: 'Account2', name: 'Product2' }
      ]));

      const result = Rules_ad_1(mockProps, stageInfo);
      const [filteredFields] = (rulesUtils as jest.Mock).mock.calls[0];
      expect(filteredFields[0].length).toBeGreaterThan(2); // Should have additional grouped fields
    });
  });

  describe('Product Type Specific Rules', () => {
    it('should hide specific fields for product type 307', () => {
      const stageInfo = createStageInfo({
        products: [
          { product_type: '307', product_category: 'CA' }
        ]
      });
      localStorage.setItem('products', JSON.stringify([
        { product_type: '307', product_category_name: 'Current Account', name: 'Special Account' }
      ]));

      const result = Rules_ad_1(mockProps, stageInfo);
      const [_, validationObj] = (rulesUtils as jest.Mock).mock.calls[0];
      
      expect(validationObj.hidden[0]).toEqual(
        expect.arrayContaining([
          'reason_for_account_rwb',
          'source_of_fund_rwb',
          'Initial_deposit_rwb'
        ])
      );
    });

    it('should handle TD product category', () => {
      const stageInfo = createStageInfo({
        products: [
          { product_type: '337', product_category: 'TD' }
        ]
      });
      localStorage.setItem('products', JSON.stringify([
        { product_type: '337', product_category_name: 'Term Deposit', name: 'Fixed Deposit' }
      ]));

      const result = Rules_ad_1(mockProps, stageInfo);
      const [filteredFields, validationObj] = (rulesUtils as jest.Mock).mock.calls[0];
      
      // Check Time Deposit Details were added
      expect(filteredFields[0].some((f: any) => f.field_set_name === 'Time Deposit Details')).toBe(true);
      
      // Check component type was changed
      const currencyField = filteredFields[0]
        .find((f: any) => f.field_set_name === 'Time Deposit Details')
        ?.fields.find((f: any) => f.logical_field_name === 'td_product_currency_value');
      expect(currencyField?.component_type).toBe('SelectionBox');
      
      // Check hidden fields
      expect(validationObj.hidden[0]).toEqual(
        expect.arrayContaining([
          'debit_card_request_rwb',
          'existing_account_no_dc',
          'issuance_type'
        ])
      );
      
      // Check modifyVisibility fields
      expect(validationObj.modifyVisibility[0]).toEqual(
        expect.arrayContaining([
          'td_product_currency_value',
          'td_depoist_amount'
        ])
      );
    });

    it('should handle product combinations 337 and 310', () => {
      const stageInfo = createStageInfo({
        products: [
          { product_type: '337' },
          { product_type: '310' }
        ]
      });
      const result = Rules_ad_1(mockProps, stageInfo);
      const [_, validationObj] = (rulesUtils as jest.Mock).mock.calls[0];
      
      expect(validationObj.hidden[0]).toEqual(
        expect.arrayContaining([
          'cheque_book_request_rwb',
          'reason_for_account_rwb'
        ])
      );
    });
  });

  describe('Repeat Count Handling', () => {
    it('should create additional fields based on no_of_accounts_rwb_a_1', () => {
      const stageInfo = createStageInfo({
        applicants: {
          no_of_accounts_rwb_a_1: 3
        },
        products: [
          { product_type: '310' }
        ]
      });
      const result = Rules_ad_1(mockProps, stageInfo);
      const [filteredFields] = (rulesUtils as jest.Mock).mock.calls[0];
      
      // Should have Additional Details and Banking Services for each repeat
      const additionalDetails = filteredFields[0].filter((f: any) => 
        f.field_set_name.includes('Additional Details'));
      expect(additionalDetails.length).toBe(3);
      
      const bankingServices = filteredFields[0].filter((f: any) => 
        f.field_set_name.includes('Banking Services'));
      expect(bankingServices.length).toBe(3);
    });
  });

  describe('Edge Cases', () => {
    it('should handle empty products in localStorage', () => {
      localStorage.setItem('products', '[]');
      const result = Rules_ad_1(mockProps, createStageInfo());
      expect(result).toBeDefined();
    });

    it('should handle missing no_of_accounts_rwb_a_1', () => {
      const stageInfo = createStageInfo();
      delete stageInfo.applicants.no_of_accounts_rwb_a_1;
      const result = Rules_ad_1(mockProps, stageInfo);
      expect(result).toBeDefined();
    });

    it('should handle empty props', () => {
      const result = Rules_ad_1([], createStageInfo());
      expect(result).toBeDefined();
    });

    it('should handle missing field_set_name', () => {
      const modifiedProps = [[{ fields: [] }]];
      const result = Rules_ad_1(modifiedProps, createStageInfo());
      expect(result).toBeDefined();
    });
  });
});
