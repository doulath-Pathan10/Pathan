import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import Text from './Text';

// Mock the redux store
const mockStore = configureStore({
  reducer: {
    stages: () => ({
      stages: [{
        stageId: 'bd-1',
        stageInfo: {
          applicants: {}
        }
      }],
      userInput: {
        applicants: {}
      }
    }),
    fielderror: () => ({
      error: []
    }),
    postalCode: () => ({}),
    alias: () => ({}),
    lastAccessed: () => ({})
  }
});

// Mock sessionStorage
const mockSessionStorage = (() => {
  let store: Record<string, string> = {};
  return {
    getItem: (key: string) => store[key] || null,
    setItem: (key: string, value: string) => {
      store[key] = value.toString();
    },
    clear: () => {
      store = {};
    }
  };
})();

Object.defineProperty(window, 'sessionStorage', {
  value: mockSessionStorage
});

// Mock URL functions
jest.mock('../../../utils/common/change.utils', () => ({
  ...jest.requireActual('../../../utils/common/change.utils'),
  getUrl: {
    getParameterByName: jest.fn(() => null),
    getJourneyType: jest.fn(() => null),
    getUpdatedStage: jest.fn(() => ({ updatedStageInputs: [] }))
  },
  authenticateType: jest.fn(() => 'manual'),
  fieldIdAppend: jest.fn((props) => props.data.logical_field_name + '_a_1'),
  fieldError: jest.fn(() => false),
  isFieldUpdate: jest.fn(),
  isFieldValueUpdate: jest.fn()
}));

// Mock services
jest.mock('../../../services/validation-service', () => ({
  allowOnlyCharacter: jest.fn()
}));

const mockProps = {
  data: {
    logical_field_name: 'test_field',
    rwb_label_name: 'Test Field',
    mandatory: 'No',
    type: 'text',
    length: 50,
    min_length: 3,
    regex: '^[a-zA-Z ]+$',
    hide_remove_btn: false,
    editable: true,
  },
  handleCallback: jest.fn(),
};

describe('Text Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    window.sessionStorage.setItem('currentStage', '1');
  });

  test('renders basic text input', () => {
    render(
      <Provider store={mockStore}>
        <Text {...mockProps} />
      </Provider>
    );

    expect(screen.getByLabelText('Test Field')).toBeInTheDocument();
    expect(screen.getByRole('textbox')).toBeInTheDocument();
  });

  test('handles input change', () => {
    render(
      <Provider store={mockStore}>
        <Text {...mockProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: 'Test' } });

    expect(input).toHaveValue('Test');
    expect(mockProps.handleCallback).toHaveBeenCalled();
  });

  test('shows error for invalid input', () => {
    render(
      <Provider store={mockStore}>
        <Text {...mockProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: '123' } }); // Doesn't match regex
    fireEvent.blur(input);

    expect(screen.getByText(/patterns Test Field/)).toBeInTheDocument();
  });

  test('shows error for empty mandatory field', () => {
    const mandatoryProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        mandatory: 'Yes'
      }
    };

    render(
      <Provider store={mockStore}>
        <Text {...mandatoryProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: '' } });
    fireEvent.blur(input);

    expect(screen.getByText(/cannot be empty/)).toBeInTheDocument();
  });

  test('displays character counter for embossed name fields', () => {
    const embossedProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'embossed_name'
      }
    };

    render(
      <Provider store={mockStore}>
        <Text {...embossedProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: 'Test' } });

    expect(screen.getByText('4/19')).toBeInTheDocument();
  });

  test('disables input when not editable', () => {
    const nonEditableProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        editable: false
      }
    };

    render(
      <Provider store={mockStore}>
        <Text {...nonEditableProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    expect(input).toBeDisabled();
  });

  test('shows remove button for alias fields', () => {
    const aliasProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'alias_2'
      }
    };

    render(
      <Provider store={mockStore}>
        <Text {...aliasProps} />
      </Provider>
    );

    expect(screen.getByRole('button')).toBeInTheDocument();
  });

  test('validates email fields correctly', () => {
    const emailProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'per_email_2',
        regex: '^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$'
      }
    };

    render(
      <Provider store={mockStore}>
        <Text {...emailProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    
    // Test invalid email
    fireEvent.change(input, { target: { value: 'invalid-email' } });
    expect(screen.getByText(/Test Field must contain/)).toBeInTheDocument();
  });

  test('handles NRIC validation', () => {
    const nricProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'NRIC',
        regex: '^[STFG]\\d{7}[A-Z]$'
      }
    };

    render(
      <Provider store={mockStore}>
        <Text {...nricProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: 'S1234567A' } });
    expect(screen.getByText('Please Enter Valid NRIC')).toBeInTheDocument();
  });
});
