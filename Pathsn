// api.services.test.tsx
import React from 'react';
import { render, screen, waitFor } from '@testing-library/react';
import axios from 'axios';
import { store } from '../../../utils/store/store';
import * as apiServices from './api.services';
import { CONSTANTS } from '../../../utils/common/constants';
import PreApprovalUtil from './preApprovalUtils';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock store and other dependencies
jest.mock('../../../utils/store/store', () => ({
  store: {
    getState: jest.fn(),
    dispatch: jest.fn(),
  },
}));

jest.mock('../../../utils/common/change.utils', () => ({
  getUrl: {
    getParameterByName: jest.fn(),
    getChannelRefNo: jest.fn(),
  },
}));

jest.mock('../../../services/encryption', () => jest.fn());

jest.mock('./preApprovalUtils', () => ({
  generateUUID: jest.fn().mockReturnValue('mock-uuid'),
  getAckMetaData: jest.fn().mockReturnValue('mock-ack-metadata'),
}));

describe('API Services', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    (store.getState as jest.Mock).mockImplementation(() => ({
      stages: {
        stages: [{
          stageId: 'PD-1',
          stageInfo: {
            products: [{ product_type: '1234', product_category: 'CC' }],
            applicants: [{
              HKID_a_1: 'A1234567',
              date_of_birth: '1990-01-01',
              last_name_a_1: 'Doe',
              first_name_a_1: 'John'
            }],
            application: {
              channel_reference: 'mock-channel-ref',
              channel_ref_number: 'mock-channel-ref',
              cos_ref_number: 'mock-cos-ref',
            },
            applicant_documents: [{ journey_type: 'NTC' }],
            fieldmetadata: {},
          },
          userInput: {
            applicants: [{
              mobile_number: '91234567',
              'id type': 'HKID'
            }]
          },
        }],
      },
      urlParam: {
        applicationDetails: {
          channelRefNo: 'mock-channel-ref'
        },
        resume: false,
      },
      preApproval: {
        resumeAllowed: 'N',
      },
    }));
  });

  // Test cases will go here
});
describe('getData', () => {
  it('should make a GET request and return response', async () => {
    const mockResponse = { data: 'test-data', status: 200 };
    mockedAxios.get.mockResolvedValue(mockResponse);

    const result = await apiServices.getData('test-url');
    expect(mockedAxios.get).toHaveBeenCalledWith('test-url');
    expect(result).toEqual(mockResponse);
  });

  it('should handle errors and return resolved promise with error', async () => {
    const mockError = new Error('Test error');
    mockedAxios.get.mockRejectedValue(mockError);

    const result = await apiServices.getData('test-url');
    expect(mockedAxios.get).toHaveBeenCalledWith('test-url');
    expect(result).toEqual(mockError);
    expect(store.dispatch).toHaveBeenCalled();
  });
});
describe('getPDFData', () => {
  it('should fetch PDF data and return blob URL', async () => {
    const mockPdfData = new ArrayBuffer(8);
    const mockResponse = { 
      status: 200, 
      data: mockPdfData 
    };
    mockedAxios.get.mockResolvedValue(mockResponse);

    Object.defineProperty(navigator, 'userAgent', {
      value: 'Chrome',
      writable: true
    });

    const result = await apiServices.getPDFData('test-url');
    expect(mockedAxios.get).toHaveBeenCalledWith('test-url', { responseType: 'arraybuffer' });
    expect(result).toContain('blob:');
  });

  it('should handle non-Chrome browsers', async () => {
    const mockPdfData = new ArrayBuffer(8);
    const mockResponse = { 
      status: 200, 
      data: mockPdfData 
    };
    mockedAxios.get.mockResolvedValue(mockResponse);

    Object.defineProperty(navigator, 'userAgent', {
      value: 'Firefox',
      writable: true
    });

    const result = await apiServices.getPDFData('test-url');
    expect(result).toContain('blob:');
  });

  it('should handle Safari browsers', async () => {
    const mockPdfData = new ArrayBuffer(8);
    const mockResponse = { 
      status: 200, 
      data: mockPdfData 
    };
    mockedAxios.get.mockResolvedValue(mockResponse);

    Object.defineProperty(navigator, 'userAgent', {
      value: 'Safari',
      writable: true
    });

    const result = await apiServices.getPDFData('test-url');
    expect(result).toContain('blob:');
  });

  it('should handle errors', async () => {
    const mockError = new Error('Test error');
    mockedAxios.get.mockRejectedValue(mockError);

    const result = await apiServices.getPDFData('test-url');
    expect(result).toEqual(mockError);
    expect(store.dispatch).toHaveBeenCalled();
  });
});
describe('getDataFormConfig', () => {
  it('should post form config data and dispatch actions', async () => {
    const mockResponse = {
      status: 200,
      data: {
        products: [{ name: 'Test Product' }],
        fieldmetadata: {},
        applicants: {}
      }
    };
    mockedAxios.post.mockResolvedValue(mockResponse);

    const formPayload = {
      stage: { stage_id: '', page_id: CONSTANTS.STAGE_NAMES.PD_1 },
      applicant: {}
    };

    const dispatch = jest.fn();
    await apiServices.getDataFormConfig(formPayload)(dispatch);

    expect(mockedAxios.post).toHaveBeenCalled();
    expect(dispatch).toHaveBeenCalledTimes(5); // Adjust based on actual dispatch calls
    expect(document.title).toContain('Test Product');
  });

  it('should handle resume flow', async () => {
    (store.getState as jest.Mock).mockImplementation(() => ({
      ...store.getState(),
      preApproval: { resumeAllowed: 'Y' },
    }));

    const mockResponse = {
      status: 200,
      data: {
        products: [{ name: 'Test Product' }],
        fieldmetadata: {},
        applicants: {}
      }
    };
    mockedAxios.post.mockResolvedValue(mockResponse);

    const formPayload = {
      stage: { stage_id: '', page_id: '' },
      applicant: {}
    };

    const dispatch = jest.fn();
    await apiServices.getDataFormConfig(formPayload)(dispatch);

    expect(mockedAxios.post).toHaveBeenCalled();
    expect(dispatch).toHaveBeenCalledTimes(6); // Adjust based on actual dispatch calls
  });

  it('should handle errors', async () => {
    const mockError = new Error('Test error');
    mockedAxios.post.mockRejectedValue(mockError);

    const dispatch = jest.fn();
    await apiServices.getDataFormConfig({})(dispatch);

    expect(dispatch).toHaveBeenCalled();
    expect(mockedAxios.post).toHaveBeenCalled();
  });
});
describe('getProductMetaDataInfo', () => {
  beforeEach(() => {
    (require('../../../utils/common/change.utils').getUrl.getParameterByName as jest.Mock)
      .mockImplementation((param) => {
        if (param === 'products') return '1258';
        return null;
      });
  });

  it('should fetch product metadata and dispatch actions', async () => {
    const mockResponse = {
      status: 200,
      data: {
        products: {
          '1258': [{
            product_type: '1258',
            product_category: 'PL',
            name: 'personal-instalment-loan'
          }]
        }
      }
    };
    mockedAxios.request.mockResolvedValue(mockResponse);

    const dispatch = jest.fn();
    const result = await apiServices.getProductMetaDataInfo({ search: '?products=1258' })(dispatch);

    expect(mockedAxios.request).toHaveBeenCalled();
    expect(dispatch).toHaveBeenCalled();
    expect(result[0].name).toBe('personal-instalment-loan');
  });

  it('should handle different product types', async () => {
    (require('../../../utils/common/change.utils').getUrl.getParameterByName as jest.Mock)
      .mockImplementation((param) => {
        if (param === 'products') return '1312';
        return null;
      });

    const mockResponse = {
      status: 200,
      data: {
        products: {
          '1312': [{
            product_type: '1312',
            product_category: 'PL',
            name: 'debt-consolidation'
          }]
        }
      }
    };
    mockedAxios.request.mockResolvedValue(mockResponse);

    const dispatch = jest.fn();
    const result = await apiServices.getProductMetaDataInfo({ search: '?products=1312' })(dispatch);

    expect(result[0].name).toBe('debt-consolidation');
  });

  it('should handle errors', async () => {
    const mockError = new Error('Test error');
    mockedAxios.request.mockRejectedValue(mockError);

    const dispatch = jest.fn();
    await apiServices.getProductMetaDataInfo({})(dispatch);

    expect(dispatch).toHaveBeenCalled();
  });
});
describe('getEnquiryData', () => {
  it('should post enquiry data', async () => {
    const mockResponse = { status: 200, data: {} };
    mockedAxios.post.mockResolvedValue(mockResponse);

    const productData = { product_type: '1258', product_category: 'PL' };
    const applicantsSelector = { HKID: 'A1234567', date_of_birth: '1990-01-01' };
    const channelRef = 'mock-channel-ref';

    const result = await apiServices.getEnquiryData(productData, applicantsSelector, channelRef);

    expect(mockedAxios.post).toHaveBeenCalled();
    expect(result).toEqual(mockResponse);
  });

  it('should handle errors', async () => {
    const mockError = new Error('Test error');
    mockedAxios.post.mockRejectedValue(mockError);

    const result = await apiServices.getEnquiryData({}, {}, 'mock-channel-ref');
    expect(result).toEqual(mockError);
    expect(store.dispatch).toHaveBeenCalled();
  });
});
describe('getDedupeData', () => {
  it('should post dedupe data', async () => {
    const mockResponse = { status: 200, data: {} };
    mockedAxios.post.mockResolvedValue(mockResponse);

    const result = await apiServices.getDedupeData('mock-channel-ref');
    
    expect(mockedAxios.post).toHaveBeenCalled();
    expect(result).toEqual(mockResponse);
  });

  it('should handle product type 1313', async () => {
    (store.getState as jest.Mock).mockImplementation(() => ({
      stages: {
        stages: [{
          stageInfo: {
            products: [{ product_type: '1313' }],
            applicants: [{
              HKID_a_1: 'A1234567',
              date_of_birth: '1990-01-01',
              last_name_a_1: 'Doe',
              first_name_a_1: 'John'
            }],
            application: {
              channel_reference: 'mock-channel-ref'
            },
            applicant_documents: [{ journey_type: 'NTC' }],
            fieldmetadata: {},
            lov_desc: {}
          }
        }],
        userInput: {
          applicants: [{
            mobile_number: '91234567',
            'id type': 'HKID'
          }]
        },
      },
      urlParam: {
        applicationDetails: {
          channelRefNo: 'mock-channel-ref'
        },
        resume: false,
      },
      preApproval: {
        resumeAllowed: 'N',
      },
    }));

    const mockResponse = { status: 200, data: {} };
    mockedAxios.post.mockResolvedValue(mockResponse);

   
