import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import '@testing-library/jest-dom';
import SliderWithLimit from './SliderWithLimit';
import { store } from '../../../utils/store/store';
import trustBankConstant from '../../../assets/_json/trust-bank.json';
import validateService from '../../../services/validation-service';

// Mock dependencies
jest.mock('../../../utils/store/store', () => ({
  store: {
    getState: jest.fn()
  }
}));

jest.mock('../../../utils/common/change.utils', () => ({
  isFieldUpdate: jest.fn()
}));

jest.mock('../../../services/validation-service', () => ({
  formateCurrency: jest.fn()
}));

jest.mock('../../../assets/_json/trust-bank.json', () => ({
  sliderCreditLimitLabel: 'Credit Limit',
  sliderAvailabeCrdLmtLabel: 'available credit',
  sliderCreditLimitNote: 'Note: This is your credit limit',
  findOutMoreLabel: 'Find out more'
}));

jest.mock('../slider/slider', () => {
  return function MockSlider({ options, updateSliderValue }) {
    return (
      <div data-testid="mock-slider">
        <input
          type="range"
          min={options.min}
          max={options.max}
          step={options.step}
          onChange={(e) => updateSliderValue(e.target.value)}
          data-testid="slider-input"
        />
      </div>
    );
  };
});

jest.mock('../model/model', () => {
  return function MockModel({ handlebuttonClick }) {
    return (
      <div data-testid="mock-model">
        <button onClick={handlebuttonClick} data-testid="model-back-button">
          Back
        </button>
      </div>
    );
  };
});

// Mock environment variable
process.env.REACT_APP_TRUST_LIMIT_FIND_OUT_MORE = 'https://example.com/find-out-more';

describe('SliderWithLimit Component', () => {
  let mockStore;
  let mockProps;
  let mockDispatch;

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();
    
    // Mock dispatch
    mockDispatch = jest.fn();
    jest.mock('react-redux', () => ({
      ...jest.requireActual('react-redux'),
      useDispatch: () => mockDispatch
    }));

    // Mock store state
    const mockTrustBankData = {
      trustBank: {
        applicants: {
          minimum_limit_amount_portable_a_1: '1000',
          maximum_limit_amount_portable_a_1: '10000',
          phoenix_customer_limit_a_1: '8000'
        },
        products: [{
          offer_details: [{
            approved_amount: 5000
          }]
        }]
      }
    };

    store.getState.mockReturnValue(mockTrustBankData);

    // Mock validateService
    validateService.formateCurrency.mockImplementation((value) => 
      parseFloat(value).toLocaleString('en-US', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      })
    );

    // Mock props
    mockProps = {
      data: {
        logical_field_name: 'credit_limit'
      },
      handleFieldDispatch: jest.fn(),
      handleCallback: jest.fn()
    };

    // Create mock store for Provider
    mockStore = configureStore({
      reducer: {
        trustBank: (state = mockTrustBankData, action) => state
      }
    });
  });

  const renderComponent = (props = mockProps) => {
    return render(
      <Provider store={mockStore}>
        <SliderWithLimit {...props} />
      </Provider>
    );
  };

  describe('Component Rendering', () => {
    test('renders without crashing', () => {
      renderComponent();
      expect(screen.getByText('Credit Limit')).toBeInTheDocument();
    });

    test('displays initial credit limit amount', async () => {
      renderComponent();
      
      await waitFor(() => {
        expect(screen.getByText(/S\$ 1,000\.00/)).toBeInTheDocument();
      });
    });

    test('displays available credit amount', async () => {
      renderComponent();
      
      await waitFor(() => {
        expect(screen.getByText(/available credit/)).toBeInTheDocument();
      });
    });

    test('renders slider component', () => {
      renderComponent();
      expect(screen.getByTestId('mock-slider')).toBeInTheDocument();
      expect(screen.getByTestId('slider-input')).toBeInTheDocument();
    });

    test('displays credit limit note', () => {
      renderComponent();
      expect(screen.getByText('Note: This is your credit limit')).toBeInTheDocument();
    });

    test('renders find out more link with correct href', () => {
      renderComponent();
      const link = screen.getByText('Find out more');
      expect(link).toBeInTheDocument();
      expect(link.getAttribute('href')).toBe('https://example.com/find-out-more');
      expect(link.getAttribute('target')).toBe('_blank');
    });

    test('renders info icon', () => {
      renderComponent();
      const infoIcon = screen.getByRole('generic', { name: /infoIcon/i });
      expect(infoIcon).toBeInTheDocument();
    });
  });

  describe('Slider Functionality', () => {
    test('updates slider value when slider changes', async () => {
      renderComponent();
      
      const sliderInput = screen.getByTestId('slider-input');
      fireEvent.change(sliderInput, { target: { value: '3000' } });

      await waitFor(() => {
        expect(mockProps.handleFieldDispatch).toHaveBeenCalledWith('credit_limit', '3000');
      });
    });

    test('calls handleCallback with empty string when value is within approved amount', async () => {
      renderComponent();
      
      const sliderInput = screen.getByTestId('slider-input');
      fireEvent.change(sliderInput, { target: { value: '4000' } }); // Less than approved amount (5000)

      await waitFor(() => {
        expect(mockProps.handleCallback).toHaveBeenCalledWith(mockProps.data, '');
      });
    });

    test('calls handleCallback with value when value exceeds approved amount', async () => {
      renderComponent();
      
      const sliderInput = screen.getByTestId('slider-input');
      fireEvent.change(sliderInput, { target: { value: '6000' } }); // Greater than approved amount (5000)

      await waitFor(() => {
        expect(mockProps.handleCallback).toHaveBeenCalledWith(mockProps.data, '6000');
      });
    });

    test('updates available credit when slider value changes', async () => {
      renderComponent();
      
      const sliderInput = screen.getByTestId('slider-input');
      fireEvent.change(sliderInput, { target: { value: '3000' } });

      await waitFor(() => {
        // Available credit should be phoenixCustomerLimit - (sliderValue - offerApprovedAmount)
        // 8000 - (3000 - 5000) = 8000 - (-2000) = 10000
        expect(validateService.formateCurrency).toHaveBeenCalledWith('10000.00');
      });
    });
  });

  describe('Modal Functionality', () => {
    test('does not show modal initially', () => {
      renderComponent();
      expect(screen.queryByTestId('mock-model')).not.toBeInTheDocument();
    });

    test('shows modal when info icon is clicked', () => {
      renderComponent();
      
      const infoIcon = document.querySelector('.infoIcon');
      fireEvent.click(infoIcon);

      expect(screen.getByTestId('mock-model')).toBeInTheDocument();
    });

    test('hides modal when back button is clicked', () => {
      renderComponent();
      
      // Show modal first
      const infoIcon = document.querySelector('.infoIcon');
      fireEvent.click(infoIcon);
      expect(screen.getByTestId('mock-model')).toBeInTheDocument();

      // Hide modal
      const backButton = screen.getByTestId('model-back-button');
      fireEvent.click(backButton);
      expect(screen.queryByTestId('mock-model')).not.toBeInTheDocument();
    });
  });

  describe('Data Handling', () => {
    test('handles missing trust bank data gracefully', () => {
      store.getState.mockReturnValue({
        trustBank: { trustBank: null }
      });

      renderComponent();
      expect(screen.getByText('Credit Limit')).toBeInTheDocument();
    });

    test('handles missing products data', () => {
      store.getState.mockReturnValue({
        trustBank: {
          trustBank: {
            applicants: {
              minimum_limit_amount_portable_a_1: '1000',
              maximum_limit_amount_portable_a_1: '10000',
              phoenix_customer_limit_a_1: '8000'
            },
            products: []
          }
        }
      });

      renderComponent();
      expect(screen.getByText('Credit Limit')).toBeInTheDocument();
    });

    test('handles missing offer details', () => {
      store.getState.mockReturnValue({
        trustBank: {
          trustBank: {
            applicants: {
              minimum_limit_amount_portable_a_1: '1000',
              maximum_limit_amount_portable_a_1: '10000',
              phoenix_customer_limit_a_1: '8000'
            },
            products: [{
              offer_details: []
            }]
          }
        }
      });

      renderComponent();
      expect(screen.getByText('Credit Limit')).toBeInTheDocument();
    });

    test('uses minimum value when approved amount is 0', async () => {
      store.getState.mockReturnValue({
        trustBank: {
          trustBank: {
            applicants: {
              minimum_limit_amount_portable_a_1: '1000',
              maximum_limit_amount_portable_a_1: '10000',
              phoenix_customer_limit_a_1: '8000'
            },
            products: [{
              offer_details: [{
                approved_amount: 0
              }]
            }]
          }
        }
      });

      renderComponent();
      
      const sliderInput = screen.getByTestId('slider-input');
      fireEvent.change(sliderInput, { target: { value: '1000' } }); // Equal to min value

      await waitFor(() => {
        expect(mockProps.handleCallback).toHaveBeenCalledWith(mockProps.data, '');
      });
    });
  });

  describe('Currency Formatting', () => {
    test('formats currency values correctly', async () => {
      renderComponent();
      
      await waitFor(() => {
        expect(validateService.formateCurrency).toHaveBeenCalledWith('1000.00');
        expect(validateService.formateCurrency).toHaveBeenCalledWith('8000.00');
      });
    });
  });

  describe('Slider Options', () => {
    test('sets correct slider options', () => {
      renderComponent();
      
      const sliderInput = screen.getByTestId('slider-input');
      expect(sliderInput.getAttribute('min')).toBe('1000');
      expect(sliderInput.getAttribute('max')).toBe('10000');
      expect(sliderInput.getAttribute('step')).toBe('500');
    });
  });

  describe('Edge Cases', () => {
    test('handles invalid numeric values in trust bank data', () => {
      store.getState.mockReturnValue({
        trustBank: {
          trustBank: {
            applicants: {
              minimum_limit_amount_portable_a_1: 'invalid',
              maximum_limit_amount_portable_a_1: 'invalid',
              phoenix_customer_limit_a_1: 'invalid'
            },
            products: [{
              offer_details: [{
                approved_amount: 'invalid'
              }]
            }]
          }
        }
      });

      renderComponent();
      expect(screen.getByText('Credit Limit')).toBeInTheDocument();
    });

    test('handles component unmounting during async operations', () => {
      const { unmount } = renderComponent();
      unmount();
      // Should not throw any errors
    });
  });
});
