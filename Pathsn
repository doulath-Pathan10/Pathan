import React from 'react';
import { render, screen, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import { store } from './utils/store/store';
import * as activityDetector from 'react-activity-detector';

// Mock child components and modules
jest.mock('./router/main', () => () => <div>Main Component</div>);
jest.mock('./shared/components/model/model', () => () => <div>Model Component</div>);
jest.mock('./shared/components/spinner/spinner', () => () => <div>Spinner Component</div>);
jest.mock('./shared/components/model/dynamic-model', () => () => <div>DynamicModel Component</div>);
jest.mock('./shared/components/model/idle-time-out', () => () => <div>IdleTimeOutModel Component</div>);
jest.mock('react-activity-detector', () => ({
  __esModule: true,
  default: jest.fn().mockImplementation(({ children }) => children),
}));
jest.mock('./services/track-events', () => ({
  triggerAdobeEvent: jest.fn(),
}));

describe('App Component', () => {
  const renderApp = () => {
    return render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should render without crashing', () => {
    renderApp();
    expect(screen.getByText('Main Component')).toBeInTheDocument();
  });

  it('should disable right click', () => {
    const addEventListenerMock = jest.spyOn(window, 'addEventListener');
    const preventDefaultMock = jest.fn();
    
    renderApp();
    
    // Simulate right click event
    const event = new MouseEvent('contextmenu', { bubbles: true });
    event.preventDefault = preventDefaultMock;
    window.dispatchEvent(event);
    
    expect(addEventListenerMock).toHaveBeenCalledWith('contextmenu', expect.any(Function));
    expect(preventDefaultMock).toHaveBeenCalled();
  });

  it('should show spinner when loaderState is true', () => {
    // Mock the useSelector to return loading state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: true } },
      error: { errors: [], exceptionList: [] }
    }));
    
    renderApp();
    expect(screen.getByText('Spinner Component')).toBeInTheDocument();
  });

  it('should show error model when there are errors', () => {
    // Mock the useSelector to return error state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { errors: ['Some error'], exceptionList: [] }
    }));
    
    renderApp();
    expect(screen.getByText('Model Component')).toBeInTheDocument();
  });

  it('should show dynamic model when there are exceptions', () => {
    // Mock the useSelector to return exception state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { errors: [], exceptionList: [{ error_header: 'Exception' }] }
    }));
    
    renderApp();
    expect(screen.getByText('DynamicModel Component')).toBeInTheDocument();
  });

  it('should trigger adobe event on form errors', () => {
    const triggerAdobeEventMock = jest.spyOn(require('./services/track-events'), 'triggerAdobeEvent');
    
    // Mock the useSelector to return error state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { 
        errors: ['Some error'], 
        exceptionList: [{ error_header: 'Exception' }] 
      }
    }));
    
    renderApp();
    expect(triggerAdobeEventMock).toHaveBeenCalledWith('formError');
  });

  it('should trigger adobe event on browser close', () => {
    const triggerAdobeEventMock = jest.spyOn(require('./services/track-events'), 'triggerAdobeEvent');
    const addEventListenerMock = jest.spyOn(window, 'addEventListener');
    
    renderApp();
    
    // Verify event listener was added
    expect(addEventListenerMock).toHaveBeenCalledWith('unload', expect.any(Function));
    
    // Simulate unload event
    const event = new Event('unload');
    window.dispatchEvent(event);
    
    expect(triggerAdobeEventMock).toHaveBeenCalledWith('formAbandonment', 'BrowserClose');
  });

  describe('Idle Timeout Handling', () => {
    it('should show idle timeout popup when idle', () => {
      // Mock the useSelector to return default state
      jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
        loader: { isFetching: { isFetching: false } },
        error: { errors: [], exceptionList: [] }
      }));
      
      renderApp();
      
      // Simulate idle state
      act(() => {
        const onIdle = activityDetector.default.mock.calls[0][0].onIdle;
        onIdle();
      });
      
      expect(screen.getByText('IdleTimeOutModel Component')).toBeInTheDocument();
    });

    it('should not show idle timeout popup when loader is active', () => {
      // Mock the useSelector to return loading state
      jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
        loader: { isFetching: { isFetching: true } },
        error: { errors: [], exceptionList: [] }
      }));
      
      renderApp();
      
      // Simulate idle state
      act(() => {
        const onIdle = activityDetector.default.mock.calls[0][0].onIdle;
        onIdle();
      });
      
      expect(screen.queryByText('IdleTimeOutModel Component')).not.toBeInTheDocument();
    });

    it('should close idle timeout popup when handlePopUpClick is called', () => {
      // Mock the useSelector to return default state
      jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
        loader: { isFetching: { isFetching: false } },
        error: { errors: [], exceptionList: [] }
      }));
      
      const { rerender } = render(
        <Provider store={store}>
          <BrowserRouter>
            <App />
          </BrowserRouter>
        </Provider>
      );
      
      // Simulate idle state
      act(() => {
        const onIdle = activityDetector.default.mock.calls[0][0].onIdle;
        onIdle();
      });
      
      expect(screen.getByText('IdleTimeOutModel Component')).toBeInTheDocument();
      
      // Simulate popup close
      act(() => {
        const handlePopUpClick = activityDetector.default.mock.calls[0][0].handlePopUpClick;
        handlePopUpClick();
      });
      
      rerender(
        <Provider store={store}>
          <BrowserRouter>
            <App />
          </BrowserRouter>
        </Provider>
      );
      
      expect(screen.queryByText('IdleTimeOutModel Component')).not.toBeInTheDocument();
    });
  });
});
