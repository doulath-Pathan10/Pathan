import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { configureStore } from '@reduxjs/toolkit';
import '@testing-library/jest-dom';
import axios from 'axios';
import DocumentUpload from './DocumentUpload';

// Mock modules
jest.mock('axios');
jest.mock('../../../services/common-service');
jest.mock('../../../services/track-events');
jest.mock('./document-upload.utils');
jest.mock('../../../utils/common/change.utils');

const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock store setup
const createMockStore = (initialState = {}) => {
  return configureStore({
    reducer: {
      documentUploadList: (state = mockDocumentState, action) => state,
      valueUpdate: (state = mockValueUpdateState, action) => state,
      stages: (state = mockStagesState, action) => state,
      loader: (state = { isFetching: false }, action) => state,
      urlparam: (state = {}, action) => state,
    },
    preloadedState: initialState,
  });
};

// Mock data
const mockDocumentState = {
  responseDocuments: [
    {
      document_list: [
        {
          document_category_code: 'IDENTITY',
          document_category: 'Identity Document',
          min_options_req: 1,
          docCheck: 'N',
          isSlectedForUpload: 'N',
          document_options: [
            {
              document_types: [
                {
                  document_type_code: 'R0001',
                  document_type: 'NRIC',
                  document_requested_stage: 'BD',
                  uploaded_documents: [],
                  selectDocument: null,
                }
              ]
            }
          ]
        }
      ],
      isSignatureDoc: false
    }
  ],
  finalDocumentList: []
};

const mockStagesState = {
  stages: [
    {
      stageId: 'doc',
      stageInfo: {
        application: {
          channel_reference: 'TEST123',
          application_reference: 'APP123'
        },
        applicant_documents: [
          {
            document_list: [
              {
                document_category_code: 'IDENTITY',
                document_category: 'Identity Document',
                min_options_req: 1,
                document_options: [
                  {
                    document_types: [
                      {
                        document_type_code: 'R0001',
                        document_type: 'NRIC',
                        document_requested_stage: 'BD'
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  ],
  journeyType: 'ETC',
  userInput: {
    applicants: {}
  },
  isDocumentUpload: false,
  isDocument: false
};

const mockValueUpdateState = {
  backNavigation: {
    nextStageId: null
  }
};

const mockProps = {
  backHandler: jest.fn()
};

// Mock implementations
const mockDispatch = jest.fn();
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useDispatch: () => mockDispatch,
}));

// Setup wrapper component
const renderWithProviders = (component, { store = createMockStore() } = {}) => {
  return render(
    <Provider store={store}>
      <BrowserRouter>
        {component}
      </BrowserRouter>
    </Provider>
  );
};

describe('DocumentUpload Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockedAxios.create.mockReturnValue(mockedAxios);
    mockedAxios.CancelToken.mockImplementation(() => ({
      source: () => ({ token: 'token', cancel: jest.fn() })
    }));
    
    // Mock environment variables
    process.env.REACT_APP_RTOB_BASE_URL = 'http://test-api.com';
    process.env.REACT_APP_DOCUMENT_UPLOAD = '/upload';
    process.env.REACT_APP_ENVIRONMENT = 'test';
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Component Rendering', () => {
    test('should render document upload component successfully', () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      expect(screen.getByText(/Upload your identity document/i)).toBeInTheDocument();
      expect(screen.getByRole('form')).toBeInTheDocument();
    });

    test('should display document upload specifications', () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      expect(screen.getByText(/JPG, PNG, TIFF, and PDF formats/i)).toBeInTheDocument();
      expect(screen.getByText(/less than 10 MB/i)).toBeInTheDocument();
      expect(screen.getByText(/Taken without flash/i)).toBeInTheDocument();
    });

    test('should show signature document specific notes when isSignatureDoc is true', () => {
      const storeWithSignatureDoc = createMockStore({
        documentUploadList: {
          ...mockDocumentState,
          responseDocuments: [
            {
              ...mockDocumentState.responseDocuments[0],
              isSignatureDoc: true
            }
          ]
        }
      });

      renderWithProviders(<DocumentUpload {...mockProps} />, { store: storeWithSignatureDoc });
      
      expect(screen.getByText(/JPG and PNG formats only for Signature Specimen/i)).toBeInTheDocument();
      expect(screen.getByText(/I confirm that the electronic image of my signature/i)).toBeInTheDocument();
    });
  });

  describe('Document Selection', () => {
    test('should handle document selection via radio button', async () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const radioButton = screen.getByRole('radio');
      fireEvent.click(radioButton);
      
      await waitFor(() => {
        expect(mockDispatch).toHaveBeenCalled();
      });
    });

    test('should show upload button after document selection', async () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const uploadButton = screen.getByTestId('upload');
      expect(uploadButton).toBeInTheDocument();
    });

    test('should show error when trying to upload without selecting document', async () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const uploadButton = screen.getByTestId('upload');
      fireEvent.click(uploadButton);
      
      await waitFor(() => {
        expect(mockDispatch).toHaveBeenCalled();
      });
    });
  });

  describe('File Upload Functionality', () => {
    test('should handle file upload successfully', async () => {
      const mockFile = new File(['test'], 'test.pdf', { type: 'application/pdf' });
      const mockResponse = {
        data: {
          docId: 'DOC123',
          status: 'Accepted'
        }
      };

      mockedAxios.post.mockResolvedValue(mockResponse);

      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const fileInput = screen.getByRole('textbox', { hidden: true }) || 
                      document.querySelector('input[type="file"]');
      
      if (fileInput) {
        await act(async () => {
          fireEvent.change(fileInput, { target: { files: [mockFile] } });
        });

        await waitFor(() => {
          expect(mockedAxios.post).toHaveBeenCalled();
        });
      }
    });

    test('should show upload progress during file upload', async () => {
      const mockFile = new File(['test'], 'test.pdf', { type: 'application/pdf' });
      
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const fileInput = document.querySelector('input[type="file"]');
      
      if (fileInput) {
        await act(async () => {
          fireEvent.change(fileInput, { target: { files: [mockFile] } });
        });

        expect(screen.getByText(/Uploading in progress/i)).toBeInTheDocument();
      }
    });

    test('should handle file upload failure', async () => {
      const mockFile = new File(['test'], 'test.pdf', { type: 'application/pdf' });
      
      mockedAxios.post.mockRejectedValue(new Error('Upload failed'));

      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const fileInput = document.querySelector('input[type="file"]');
      
      if (fileInput) {
        await act(async () => {
          fireEvent.change(fileInput, { target: { files: [mockFile] } });
        });

        await waitFor(() => {
          expect(screen.getByText(/Upload failed/i)).toBeInTheDocument();
        });
      }
    });

    test('should validate file format and size', async () => {
      const invalidFile = new File(['test'], 'test.txt', { type: 'text/plain' });
      
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const fileInput = document.querySelector('input[type="file"]');
      
      if (fileInput) {
        await act(async () => {
          fireEvent.change(fileInput, { target: { files: [invalidFile] } });
        });

        await waitFor(() => {
          expect(mockDispatch).toHaveBeenCalled();
        });
      }
    });
  });

  describe('File Management', () => {
    test('should allow file deletion', async () => {
      const storeWithUploadedDoc = createMockStore({
        documentUploadList: {
          ...mockDocumentState,
          responseDocuments: [
            {
              ...mockDocumentState.responseDocuments[0],
              document_list: [
                {
                  ...mockDocumentState.responseDocuments[0].document_list[0],
                  document_options: [
                    {
                      document_types: [
                        {
                          ...mockDocumentState.responseDocuments[0].document_list[0].document_options[0].document_types[0],
                          uploaded_documents: [
                            {
                              docId: 'DOC123',
                              documentStatus: 'Accepted',
                              document_name: 'test.pdf'
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      });

      renderWithProviders(<DocumentUpload {...mockProps} />, { store: storeWithUploadedDoc });
      
      const deleteButton = screen.getByRole('button', { name: /delete/i }) ||
                          document.querySelector('.upload-icon--success');
      
      if (deleteButton) {
        fireEvent.click(deleteButton);
        
        await waitFor(() => {
          expect(mockDispatch).toHaveBeenCalled();
        });
      }
    });

    test('should allow adding additional documents', async () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const addButton = screen.queryByText(/Upload/i);
      
      if (addButton) {
        fireEvent.click(addButton);
        
        await waitFor(() => {
          expect(mockDispatch).toHaveBeenCalled();
        });
      }
    });
  });

  describe('Form Submission', () => {
    test('should submit documents successfully', async () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const form = screen.getByRole('form');
      fireEvent.submit(form);
      
      await waitFor(() => {
        expect(mockDispatch).toHaveBeenCalled();
      });
    });

    test('should validate mandatory documents before submission', async () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const form = screen.getByRole('form');
      fireEvent.submit(form);
      
      await waitFor(() => {
        expect(mockDispatch).toHaveBeenCalled();
      });
    });

    test('should show error for missing mandatory documents', async () => {
      const storeWithMandatoryDoc = createMockStore({
        documentUploadList: {
          ...mockDocumentState,
          responseDocuments: [
            {
              ...mockDocumentState.responseDocuments[0],
              document_list: [
                {
                  ...mockDocumentState.responseDocuments[0].document_list[0],
                  min_options_req: 1
                }
              ]
            }
          ]
        }
      });

      renderWithProviders(<DocumentUpload {...mockProps} />, { store: storeWithMandatoryDoc });
      
      const form = screen.getByRole('form');
      fireEvent.submit(form);
      
      await waitFor(() => {
        expect(mockDispatch).toHaveBeenCalled();
      });
    });
  });

  describe('Navigation and Back Handler', () => {
    test('should handle back navigation', () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      // Trigger back navigation through footer or back button
      // This would depend on the Footer component implementation
      expect(mockProps.backHandler).toBeDefined();
    });

    test('should handle back navigation with document upload flow', () => {
      const storeWithDocumentUpload = createMockStore({
        stages: {
          ...mockStagesState,
          isDocument: true
        }
      });

      renderWithProviders(<DocumentUpload {...mockProps} />, { store: storeWithDocumentUpload });
      
      // Test back handler logic
      expect(mockProps.backHandler).toBeDefined();
    });
  });

  describe('Error Handling', () => {
    test('should display error popup when document error occurs', async () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      // Trigger an error condition
      const uploadButton = screen.getByTestId('upload');
      fireEvent.click(uploadButton);
      
      await waitFor(() => {
        // Check if error popup is displayed
        expect(mockDispatch).toHaveBeenCalled();
      });
    });

    test('should handle axios cancel token for upload cancellation', async () => {
      const mockFile = new File(['test'], 'test.pdf', { type: 'application/pdf' });
      
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const fileInput = document.querySelector('input[type="file"]');
      
      if (fileInput) {
        await act(async () => {
          fireEvent.change(fileInput, { target: { files: [mockFile] } });
        });

        // Test upload cancellation
        const cancelElement = screen.queryByText(/Uploading in progress/i);
        if (cancelElement) {
          fireEvent.click(cancelElement);
        }
      }
    });
  });

  describe('Document Stage Filtering', () => {
    test('should filter documents based on stage ID (doc)', () => {
      const storeWithDocStage = createMockStore({
        stages: {
          ...mockStagesState,
          stages: [
            {
              ...mockStagesState.stages[0],
              stageId: 'doc'
            }
          ]
        }
      });

      renderWithProviders(<DocumentUpload {...mockProps} />, { store: storeWithDocStage });
      
      expect(screen.getByText(/Upload your identity document/i)).toBeInTheDocument();
    });

    test('should filter documents based on stage ID (doc-2)', () => {
      const storeWithDoc2Stage = createMockStore({
        stages: {
          ...mockStagesState,
          stages: [
            {
              ...mockStagesState.stages[0],
              stageId: 'doc-2'
            }
          ]
        }
      });

      renderWithProviders(<DocumentUpload {...mockProps} />, { store: storeWithDoc2Stage });
      
      expect(screen.getByText(/Upload your identity document/i)).toBeInTheDocument();
    });
  });

  describe('Upload Enable State', () => {
    test('should enable upload when auth param is upload', () => {
      // Mock URL parameter
      Object.defineProperty(window, 'location', {
        value: {
          search: '?auth=upload'
        },
        writable: true
      });

      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      expect(mockDispatch).toHaveBeenCalled();
    });

    test('should enable upload when isDocumentUpload is true in store', () => {
      const storeWithUploadEnabled = createMockStore({
        stages: {
          ...mockStagesState,
          isDocumentUpload: true
        }
      });

      renderWithProviders(<DocumentUpload {...mockProps} />, { store: storeWithUploadEnabled });
      
      expect(mockDispatch).toHaveBeenCalled();
    });
  });

  describe('Component Lifecycle', () => {
    test('should dispatch loader actions on mount', () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      expect(mockDispatch).toHaveBeenCalled();
    });

    test('should clean up on unmount', () => {
      const { unmount } = renderWithProviders(<DocumentUpload {...mockProps} />);
      
      unmount();
      
      // Verify cleanup actions
      expect(mockDispatch).toHaveBeenCalled();
    });
  });

  describe('Accessibility', () => {
    test('should have proper ARIA labels and roles', () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      expect(screen.getByRole('form')).toBeInTheDocument();
      expect(screen.getByTestId('upload')).toBeInTheDocument();
    });

    test('should support keyboard navigation', () => {
      renderWithProviders(<DocumentUpload {...mockProps} />);
      
      const uploadButton = screen.getByTestId('upload');
      uploadButton.focus();
      expect(uploadButton).toHaveFocus();
    });
  });
});
