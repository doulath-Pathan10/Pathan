describe('Additional renderComponent Tests for Coverage', () => {
  const mockHandleCallback = jest.fn();
  const mockHandleFieldDispatch = jest.fn();
  const mockUserInput = { testField: 'testValue' };

  // Test all phone number variations that should render SelectionBox
  const phoneSelectionBoxCases = [
    'mobile_number_rwb',
    'mobile_1',
    'mobile_2',
    'overseas_mobile1_contact_no',
    'overseas_mobile2_contact_no',
    'ofc1_number',
    'ofc2_number',
    'home_phone2_number',
    'office_phone1_number',
    'office_phone2_number',
    'ohph1_number',
    'ohph2_number',
    'home_phone_number_rwb'
  ];

  phoneSelectionBoxCases.forEach((fieldName) => {
    it(`should render SelectionBox for Phone type when logical_field_name is ${fieldName}`, () => {
      const currentSection = {
        component_type: 'Phone',
        logical_field_name: fieldName,
      };

      const { container } = render(
        renderComponent(
          currentSection,
          0,
          mockHandleCallback,
          mockHandleFieldDispatch,
          mockUserInput
        )
      );

      expect(container).toHaveTextContent('SelectionBox Mock');
    });
  });

  // Test all phone number variations that should render Phone component
  const phoneComponentCases = [
    'mobile_number',
    'mobile_1_add',
    'mobile_2_add',
    'overseas_mobile1',
    'overseas_mobile2',
    'ofc1',
    'ofc2',
    'home_phone2',
    'office_phone1',
    'office_phone2',
    'ohph1',
    'ohph2',
    'home_phone_number'
  ];

  phoneComponentCases.forEach((fieldName) => {
    it(`should render Phone component for Phone type when logical_field_name is ${fieldName}`, () => {
      const currentSection = {
        component_type: 'Phone',
        logical_field_name: fieldName,
      };

      const { container } = render(
        renderComponent(
          currentSection,
          0,
          mockHandleCallback,
          mockHandleFieldDispatch,
          mockUserInput
        )
      );

      expect(container).toHaveTextContent('Phone Mock');
    });
  });

  // Test all component types in the mapping
  const componentTypes = [
    'Toggle',
    'Number',
    'Information',
    'OtherMyinfo',
    'TypeAhead',
    'Button',
    'Amount',
    'SliderWithLimit',
    'SliderWithCurrency',
    'Date'
  ];

  componentTypes.forEach((type) => {
    it(`should render ${type} component for ${type} type`, () => {
      const currentSection = {
        component_type: type,
        logical_field_name: `test_${type.toLowerCase()}`,
      };

      const { container } = render(
        renderComponent(
          currentSection,
          0,
          mockHandleCallback,
          mockHandleFieldDispatch,
          mockUserInput
        )
      );

      expect(container).toHaveTextContent(`${type} Mock`);
    });
  });

  // Test case for SliderWithlimit (notice lowercase 'l')
  it('should render SliderWithLimit for SliderWithlimit type', () => {
    const currentSection = {
      component_type: 'SliderWithlimit',
      logical_field_name: 'test_slider',
    };

    const { container } = render(
      renderComponent(
        currentSection,
        0,
        mockHandleCallback,
        mockHandleFieldDispatch,
        mockUserInput
      )
    );

    expect(container).toHaveTextContent('SliderWithLimit Mock');
  });

  // Test case for empty component_type
  it('should return undefined for empty component_type', () => {
    const currentSection = {
      component_type: '',
      logical_field_name: 'test_empty',
    };

    const result = renderComponent(
      currentSection,
      0,
      mockHandleCallback,
      mockHandleFieldDispatch,
      mockUserInput
    );

    expect(result).toBeUndefined();
  });

  // Test case for null component_type
  it('should return undefined for null component_type', () => {
    const currentSection = {
      component_type: null,
      logical_field_name: 'test_null',
    };

    const result = renderComponent(
      currentSection as any,
      0,
      mockHandleCallback,
      mockHandleFieldDispatch,
      mockUserInput
    );

    expect(result).toBeUndefined();
  });

  // Test case for undefined component_type
  it('should return undefined for undefined component_type', () => {
    const currentSection = {
      logical_field_name: 'test_undefined',
    };

    const result = renderComponent(
      currentSection as any,
      0,
      mockHandleCallback,
      mockHandleFieldDispatch,
      mockUserInput
    );

    expect(result).toBeUndefined();
  });

  // Test case for component_type with only whitespace
  it('should return undefined for whitespace-only component_type', () => {
    const currentSection = {
      component_type: '   ',
      logical_field_name: 'test_whitespace',
    };

    const result = renderComponent(
      currentSection,
      0,
      mockHandleCallback,
      mockHandleFieldDispatch,
      mockUserInput
    );

    expect(result).toBeUndefined();
  });

  // Test case for component with additional props
  it('should pass through additional props from currentSection', () => {
    const currentSection = {
      component_type: 'Text',
      logical_field_name: 'test_text',
      customProp1: 'value1',
      customProp2: { nested: 'value' },
      required: true
    };

    const { container } = render(
      renderComponent(
        currentSection,
        0,
        mockHandleCallback,
        mockHandleFieldDispatch,
        mockUserInput
      )
    );

    expect(container).toHaveTextContent('customProp1');
    expect(container).toHaveTextContent('value1');
    expect(container).toHaveTextContent('nested');
    expect(container).toHaveTextContent('required');
  });

  // Test case for verifying the index parameter is not used
  it('should not use the index parameter in rendering', () => {
    const currentSection = {
      component_type: 'Text',
      logical_field_name: 'test_index',
    };

    const { container } = render(
      renderComponent(
        currentSection,
        999, // Unlikely index value
        mockHandleCallback,
        mockHandleFieldDispatch,
        mockUserInput
      )
    );

    // Verify the rendered component doesn't include the index
    expect(container).not.toHaveTextContent('999');
  });
});
