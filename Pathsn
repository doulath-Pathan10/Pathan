import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import Text from './Text';
import { StoreModel } from '../../../utils/model/common-model';
import { stagesReducer } from '../../../utils/store/stages-slice';
import { fieldErrorReducer } from '../../../utils/store/field-error-slice';

// Mock the store
const createMockStore = (initialState: Partial<StoreModel>) => {
  return configureStore({
    reducer: {
      stages: stagesReducer,
      fielderror: fieldErrorReducer,
      // Add other reducers if needed
    },
    preloadedState: initialState as any,
  });
};

// Mock props
const mockProps = {
  data: {
    logical_field_name: 'test_field',
    rwb_label_name: 'Test Field',
    mandatory: 'No',
    type: 'text',
    length: 50,
    min_length: 3,
    regex: '^[a-zA-Z ]+$',
    hide_remove_btn: false,
    editable: true,
  },
  handleCallback: jest.fn(),
};

describe('Text Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    sessionStorage.setItem('currentStage', '1');
  });

  test('renders without crashing', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    render(
      <Provider store={store}>
        <Text {...mockProps} />
      </Provider>
    );

    expect(screen.getByLabelText('Test Field')).toBeInTheDocument();
  });

  test('displays label correctly', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    render(
      <Provider store={store}>
        <Text {...mockProps} />
      </Provider>
    );

    expect(screen.getByText('Test Field')).toBeInTheDocument();
  });

  test('handles input change', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    render(
      <Provider store={store}>
        <Text {...mockProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: 'Test Value' } });

    expect(mockProps.handleCallback).toHaveBeenCalled();
    expect(input).toHaveValue('Test Value');
  });

  test('shows error for invalid input', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    render(
      <Provider store={store}>
        <Text {...mockProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: '123' } }); // Invalid as per regex
    fireEvent.blur(input);

    expect(screen.getByText(/patterns Test Field/)).toBeInTheDocument();
  });

  test('shows error for mandatory field', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    const mandatoryProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        mandatory: 'Yes'
      }
    };

    render(
      <Provider store={store}>
        <Text {...mandatoryProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: '' } });
    fireEvent.blur(input);

    expect(screen.getByText(/cannot be empty/)).toBeInTheDocument();
  });

  test('displays character counter for embossed name fields', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    const embossedProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'embossed_name'
      }
    };

    render(
      <Provider store={store}>
        <Text {...embossedProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    fireEvent.change(input, { target: { value: 'Test' } });

    expect(screen.getByText('4/19')).toBeInTheDocument();
  });

  test('disables input when not editable', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    const nonEditableProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        editable: false
      }
    };

    render(
      <Provider store={store}>
        <Text {...nonEditableProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    expect(input).toBeDisabled();
  });

  test('validates NRIC correctly', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    const nricProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'NRIC',
        regex: '^[STFG]\\d{7}[A-Z]$'
      }
    };

    render(
      <Provider store={store}>
        <Text {...nricProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    
    // Test invalid NRIC
    fireEvent.change(input, { target: { value: 'S1234567A' } });
    expect(screen.getByText('Please Enter Valid NRIC')).toBeInTheDocument();
    
    // Test valid NRIC (example - actual validation would need real valid NRIC)
    // Note: You'd need to use a real valid NRIC for this test to pass
    // fireEvent.change(input, { target: { value: 'S1234567A' } });
    // expect(screen.queryByText('Please Enter Valid NRIC')).not.toBeInTheDocument();
  });

  test('shows remove button for alias fields', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    const aliasProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'alias_2'
      }
    };

    render(
      <Provider store={store}>
        <Text {...aliasProps} />
      </Provider>
    );

    expect(screen.getByRole('button')).toBeInTheDocument();
  });

  test('handles postal code fields correctly', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      },
      postalCode: {
        postalCode: {
          block_a_1: '123',
          street_name_a_1: 'Test Street',
          building_name_a_1: 'Test Building'
        }
      }
    });

    const postalProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'block'
      }
    };

    render(
      <Provider store={store}>
        <Text {...postalProps} />
      </Provider>
    );

    expect(screen.getByLabelText('Test Field')).toHaveValue('123');
  });

  test('validates email fields correctly', () => {
    const store = createMockStore({
      stages: {
        stages: [{
          stageId: 'bd-1',
          stageInfo: {
            applicants: {}
          }
        }],
        userInput: {
          applicants: {}
        }
      }
    });

    const emailProps = {
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'per_email_2',
        regex: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'
      }
    };

    render(
      <Provider store={store}>
        <Text {...emailProps} />
      </Provider>
    );

    const input = screen.getByLabelText('Test Field');
    
    // Test invalid email
    fireEvent.change(input, { target: { value: 'invalid-email' } });
    expect(screen.getByText(/Test Field must contain/)).toBeInTheDocument();
    
    // Test valid email
    fireEvent.change(input, { target: { value: 'valid@example.com' } });
    expect(screen.queryByText(/Test Field must contain/)).not.toBeInTheDocument();
  });
});
