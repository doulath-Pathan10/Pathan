import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import DocumentUpload from './DocumentUpload';
import axios from 'axios';

// Mock Redux store
const mockStore = configureStore({
  reducer: {
    documentUploadList: () => ({
      responseDocuments: [],
      isDocumentUpdate: false
    }),
    stages: () => ({
      stages: [{
        stageInfo: {
          applicant_documents: [],
          application: {
            channel_reference: 'test123',
            application_reference: 'app123'
          },
          products: [{ product_category: 'CC' }, { product_category: 'PL' }]
        },
        journeyType: 'test',
        isDocument: false,
        isDocumentUpload: false
      }],
      userInput: {
        applicants: {}
      }
    }),
    valueUpdate: () => ({
      backNavigation: {
        nextStageId: null
      }
    }),
    loader: () => ({
      isFetching: false
    }),
    urlparam: () => ({
      urlEndPoint: null
    })
  }
});

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock other dependencies
jest.mock('../../../services/track-events');
jest.mock('../../../services/common-service');
jest.mock('../../../utils/common/change.utils');

describe('DocumentUpload Component', () => {
  const mockBackHandler = jest.fn();
  
  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
    
    // Mock getParameterByName to return null by default
    require('../../../utils/common/change.utils').getUrl.getParameterByName = jest.fn(() => null);
    require('../../../utils/common/change.utils').getUrl.getDocumentStatus = jest.fn(() => false);
    require('../../../utils/common/change.utils').getUrl.getJourneyType = jest.fn(() => null);
  });

  test('renders without crashing', () => {
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    expect(screen.getByRole('form')).toBeInTheDocument();
  });

  test('displays document headers', () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        docCheck: 'N',
        isSlectedForUpload: 'N',
        document_options: []
      }],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    expect(screen.getByText('Upload your identity proof')).toBeInTheDocument();
  });

  test('shows radio buttons when document is not selected for upload', () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        docCheck: 'N',
        isSlectedForUpload: 'N',
        document_options: [{
          document_types: [{
            document_type: 'Passport',
            document_type_code: 'PASSPORT',
            uploaded_documents: []
          }]
        }]
      }],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    expect(screen.getByLabelText('Passport')).toBeInTheDocument();
  });

  test('shows upload section when document is selected for upload', () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        docCheck: 'Y',
        isSlectedForUpload: 'Y',
        document_options: [{
          document_types: [{
            document_type: 'Passport',
            document_type_code: 'PASSPORT',
            uploaded_documents: []
          }]
        }]
      }],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    expect(screen.getByTestId('upload')).toBeInTheDocument();
  });

  test('displays error popup when trying to upload without selecting document', async () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        docCheck: 'N',
        isSlectedForUpload: 'N',
        document_options: [{
          document_types: [{
            document_type: 'Passport',
            document_type_code: 'PASSPORT',
            uploaded_documents: []
          }]
        }]
      }],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    fireEvent.click(screen.getByText('Upload'));
    
    await waitFor(() => {
      expect(screen.getByText('selectDocument')).toBeInTheDocument();
    });
  });

  test('handles file upload successfully', async () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        docCheck: 'Y',
        isSlectedForUpload: 'Y',
        document_options: [{
          document_types: [{
            document_type: 'Passport',
            document_type_code: 'PASSPORT',
            uploaded_documents: [{
              documentStatus: null,
              selectDocument: 'Passport'
            }]
          }]
        }]
      }],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    // Mock successful axios response
    mockedAxios.post.mockResolvedValueOnce({
      data: {
        docId: 'doc123',
        documentStatus: 'Accepted'
      }
    });
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    const file = new File(['test'], 'test.png', { type: 'image/png' });
    const input = screen.getByTestId('jestUpload');
    
    await act(async () => {
      fireEvent.change(input, { target: { files: [file] } });
    });
    
    await waitFor(() => {
      expect(mockedAxios.post).toHaveBeenCalled();
    });
  });

  test('handles file upload failure', async () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        docCheck: 'Y',
        isSlectedForUpload: 'Y',
        document_options: [{
          document_types: [{
            document_type: 'Passport',
            document_type_code: 'PASSPORT',
            uploaded_documents: [{
              documentStatus: null,
              selectDocument: 'Passport'
            }]
          }]
        }]
      }],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    // Mock failed axios response
    mockedAxios.post.mockRejectedValueOnce(new Error('Upload failed'));
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    const file = new File(['test'], 'test.png', { type: 'image/png' });
    const input = screen.getByTestId('jestUpload');
    
    await act(async () => {
      fireEvent.change(input, { target: { files: [file] } });
    });
    
    await waitFor(() => {
      expect(mockedAxios.post).toHaveBeenCalled();
    });
  });

  test('shows error when mandatory documents are missing on submit', async () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        min_options_req: 1,
        docCheck: 'N',
        isSlectedForUpload: 'N',
        document_options: [{
          document_types: [{
            document_type: 'Passport',
            document_type_code: 'PASSPORT',
            uploaded_documents: []
          }]
        }]
      }],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    fireEvent.submit(screen.getByRole('form'));
    
    await waitFor(() => {
      expect(screen.getByText('missingMandatoryDocument')).toBeInTheDocument();
    });
  });

  test('handles document submission successfully', async () => {
    const mockDocumentList = [{
      document_list: [{
        document_category: 'Identity Proof',
        document_category_code: 'ID_PROOF',
        min_options_req: 1,
        docCheck: 'Y',
        isSlectedForUpload: 'Y',
        document_options: [{
          document_types: [{
            document_type: 'Passport',
            document_type_code: 'PASSPORT',
            uploaded_documents: [{
              docId: 'doc123',
              documentStatus: 'Accepted'
            }]
          }]
        }]
      }],
      finalDocumentList: [],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    // Mock successful submission
    require('../../../services/common-service').documentSubmit.mockResolvedValueOnce({});
    require('../../../services/common-service').channelReference.mockResolvedValueOnce({
      data: {
        stage: {
          page_id: 'ad-1'
        }
      }
    });
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    fireEvent.submit(screen.getByRole('form'));
    
    await waitFor(() => {
      expect(require('../../../services/common-service').documentSubmit).toHaveBeenCalled();
    });
  });

  test('handles back button click', () => {
    const mockDocumentList = [{
      document_list: [],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    mockStore.getState().stages.isDocument = true;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    fireEvent.click(screen.getByText('Back'));
    
    expect(mockBackHandler).toHaveBeenCalledWith(false);
  });

  test('renders signature document notes when isSignatureDoc is true', () => {
    const mockDocumentList = [{
      document_list: [],
      isSignatureDoc: true
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    expect(screen.getByText(/I confirm that the electronic image of my signature/)).toBeInTheDocument();
  });

  test('renders different content for upload journey', () => {
    require('../../../utils/common/change.utils').getUrl.getParameterByName = jest.fn(() => 'upload');
    
    const mockDocumentList = [{
      document_list: [],
      isSignatureDoc: false
    }];
    
    mockStore.getState().documentUploadList.responseDocuments = mockDocumentList;
    
    render(
      <Provider store={mockStore}>
        <DocumentUpload backHandler={mockBackHandler} />
      </Provider>
    );
    
    expect(screen.getByText('Continue')).toBeInTheDocument();
  });
});
