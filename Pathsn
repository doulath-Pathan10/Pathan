import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import { MemoryRouter } from 'react-router-dom';
import App from './App';
import trackEvents from './services/track-events';

// Mock all the imported modules
jest.mock('./router/main', () => {
  return function Main() {
    return <div data-testid="main-component">Main Component</div>;
  };
});

jest.mock('./shared/components/model/model', () => {
  return function Model({ name, handlebuttonClick }) {
    return (
      <div data-testid="model-component">
        <span>Model: {name}</span>
        <button onClick={handlebuttonClick}>Model Button</button>
      </div>
    );
  };
});

jest.mock('./shared/components/spinner/spinner', () => {
  return function Spinner() {
    return <div data-testid="spinner-component">Loading...</div>;
  };
});

jest.mock('./shared/components/model/dynamic-model', () => {
  return function DynamicModel({ errorList }) {
    return (
      <div data-testid="dynamic-model-component">
        Dynamic Model: {JSON.stringify(errorList)}
      </div>
    );
  };
});

jest.mock('./shared/components/model/idle-time-out', () => {
  return function IdleTimeOutModel({ handlePopUpClick }) {
    return (
      <div data-testid="idle-timeout-model">
        <span>Idle Timeout</span>
        <button onClick={handlePopUpClick}>Close Idle</button>
      </div>
    );
  };
});

jest.mock('react-activity-detector', () => {
  return function ActivityDetector({ onIdle, onActive, enabled, timeout }) {
    React.useEffect(() => {
      // Store the callbacks for testing
      window.mockActivityDetector = { onIdle, onActive, enabled, timeout };
    }, [onIdle, onActive, enabled, timeout]);
    
    return <div data-testid="activity-detector">Activity Detector</div>;
  };
});

jest.mock('./services/track-events', () => ({
  triggerAdobeEvent: jest.fn(),
}));

jest.mock('./modules/dashboard/fields/fields.utils', () => ({
  submitRequest: jest.fn(),
}));

jest.mock('./utils/store/store', () => ({
  store: {},
}));

// Mock environment variable
process.env.REACT_APP_RTOB_APP_IDLE_TIMEOUT_DURATION = '30';

describe('App Component', () => {
  const createMockStore = (initialState = {}) => {
    const defaultState = {
      loader: {
        isFetching: {
          isFetching: false,
        },
      },
      error: {
        errors: [],
        exceptionList: [],
      },
      ...initialState,
    };

    return configureStore({
      reducer: {
        loader: (state = defaultState.loader) => state,
        error: (state = defaultState.error) => state,
      },
      preloadedState: defaultState,
    });
  };

  const renderWithProviders = (component, { initialState = {} } = {}) => {
    const store = createMockStore(initialState);
    return render(
      <Provider store={store}>
        <MemoryRouter>
          {component}
        </MemoryRouter>
      </Provider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
    delete window.mockActivityDetector;
    
    // Mock addEventListener and removeEventListener
    window.addEventListener = jest.fn();
    window.removeEventListener = jest.fn();
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Basic Rendering', () => {
    test('renders main component by default', () => {
      renderWithProviders(<App />);
      expect(screen.getByTestId('main-component')).toBeInTheDocument();
    });

    test('renders activity detector with correct props', () => {
      renderWithProviders(<App />);
      expect(screen.getByTestId('activity-detector')).toBeInTheDocument();
      
      // Check if ActivityDetector received correct props
      expect(window.mockActivityDetector.enabled).toBe(true);
      expect(window.mockActivityDetector.timeout).toBe(300000); // 30 * 10000
    });
  });

  describe('Context Menu Prevention', () => {
    test('prevents context menu on mount', () => {
      renderWithProviders(<App />);
      expect(window.addEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function));
    });

    test('removes context menu listener on unmount', () => {
      const { unmount } = renderWithProviders(<App />);
      unmount();
      expect(window.removeEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function));
    });
  });

  describe('Loader State Management', () => {
    test('shows spinner when loader is active', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderWithProviders(<App />, { initialState });
      expect(screen.getByTestId('spinner-component')).toBeInTheDocument();
    });

    test('does not show spinner when loader is inactive', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderWithProviders(<App />, { initialState });
      expect(screen.queryByTestId('spinner-component')).not.toBeInTheDocument();
    });
  });

  describe('Error Handling', () => {
    test('shows error model when errors exist', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: ['Some error'],
          exceptionList: [],
        },
      };

      renderWithProviders(<App />, { initialState });
      expect(screen.getByTestId('model-component')).toBeInTheDocument();
      expect(screen.getByText('Model: globalError')).toBeInTheDocument();
    });

    test('shows dynamic model when exception list exists', () => {
      const exceptionList = [{ error_header: 'Exception occurred' }];
      const initialState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: [],
          exceptionList,
        },
      };

      renderWithProviders(<App />, { initialState });
      expect(screen.getByTestId('dynamic-model-component')).toBeInTheDocument();
    });

    test('triggers adobe event when errors exist', () => {
      renderWithProviders(<App />, {
        initialState: {
          error: {
            errors: ['Some error'],
            exceptionList: [],
          },
        },
      });

      expect(trackEvents.triggerAdobeEvent).toHaveBeenCalledWith('formError');
    });

    test('triggers adobe event when exception list has error_header', () => {
      renderWithProviders(<App />, {
        initialState: {
          error: {
            errors: [],
            exceptionList: { error_header: 'Exception' },
          },
        },
      });

      expect(trackEvents.triggerAdobeEvent).toHaveBeenCalledWith('formError');
    });
  });

  describe('Idle Timeout Functionality', () => {
    test('shows idle timeout modal when idle state is true', async () => {
      renderWithProviders(<App />);

      // Simulate going idle
      act(() => {
        window.mockActivityDetector.onIdle();
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-model')).toBeInTheDocument();
      });
    });

    test('does not show idle popup when loader is active', async () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderWithProviders(<App />, { initialState });

      // Simulate going idle when loader is active
      act(() => {
        window.mockActivityDetector.onIdle();
      });

      await waitFor(() => {
        expect(screen.queryByTestId('idle-timeout-model')).not.toBeInTheDocument();
      });
    });

    test('closes idle timeout modal when close button is clicked', async () => {
      renderWithProviders(<App />);

      // Simulate going idle
      act(() => {
        window.mockActivityDetector.onIdle();
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-model')).toBeInTheDocument();
      });

      // Click close button
      fireEvent.click(screen.getByText('Close Idle'));

      await waitFor(() => {
        expect(screen.queryByTestId('idle-timeout-model')).not.toBeInTheDocument();
      });
    });

    test('resets idle state when user becomes active', async () => {
      renderWithProviders(<App />);

      // Simulate going idle
      act(() => {
        window.mockActivityDetector.onIdle();
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-model')).toBeInTheDocument();
      });

      // Simulate becoming active
      act(() => {
        window.mockActivityDetector.onActive();
      });

      await waitFor(() => {
        expect(screen.queryByTestId('idle-timeout-model')).not.toBeInTheDocument();
      });
    });
  });

  describe('Button Click Handlers', () => {
    test('handles model button click', () => {
      const initialState = {
        error: {
          errors: ['Some error'],
          exceptionList: [],
        },
      };

      renderWithProviders(<App />, { initialState });
      
      const button = screen.getByText('Model Button');
      fireEvent.click(button);
      
      // Since handleBtClick is empty, we just verify it doesn't crash
      expect(button).toBeInTheDocument();
    });
  });

  describe('Environment Configuration', () => {
    test('uses correct timeout duration from environment variable', () => {
      renderWithProviders(<App />);
      expect(window.mockActivityDetector.timeout).toBe(300000); // 30 * 10000
    });
  });

  describe('Component Integration', () => {
    test('renders all components together correctly', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: ['Error message'],
          exceptionList: [{ error_header: 'Exception' }],
        },
      };

      renderWithProviders(<App />, { initialState });

      expect(screen.getByTestId('main-component')).toBeInTheDocument();
      expect(screen.getByTestId('activity-detector')).toBeInTheDocument();
      expect(screen.getByTestId('dynamic-model-component')).toBeInTheDocument();
      expect(screen.getByTestId('model-component')).toBeInTheDocument();
    });
  });

  describe('State Updates', () => {
    test('updates loader state when selector changes', () => {
      const { rerender } = renderWithProviders(<App />);

      // Initially no spinner
      expect(screen.queryByTestId('spinner-component')).not.toBeInTheDocument();

      // Re-render with loading state
      const newInitialState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      rerender(
        <Provider store={createMockStore(newInitialState)}>
          <MemoryRouter>
            <App />
          </MemoryRouter>
        </Provider>
      );

      expect(screen.getByTestId('spinner-component')).toBeInTheDocument();
    });
  });

  describe('Edge Cases', () => {
    test('handles undefined loader selector', () => {
      const initialState = {
        loader: null,
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      expect(() => {
        renderWithProviders(<App />, { initialState });
      }).not.toThrow();
    });

    test('handles undefined error selector', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: null,
      };

      expect(() => {
        renderWithProviders(<App />, { initialState });
      }).not.toThrow();
    });

    test('handles empty exception list array', () => {
      const initialState = {
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderWithProviders(<App />, { initialState });
      expect(screen.queryByTestId('dynamic-model-component')).not.toBeInTheDocument();
    });
  });
});
