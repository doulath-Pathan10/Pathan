import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import '@testing-library/jest-dom';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import { createStore, combineReducers } from 'redux';
import App from '../App'; // Adjust path as needed

// Mock all external dependencies
jest.mock('../router/main', () => {
  const Main = () => <div data-testid="main-router">Main Router</div>;
  return Main;
});

jest.mock('../shared/components/model/model', () => {
  const Model = ({ name, handlebuttonClick }) => (
    <div data-testid="error-model">
      <span>Error Model: {name}</span>
      <button onClick={handlebuttonClick} data-testid="error-model-button">
        Close Error
      </button>
    </div>
  );
  return Model;
});

jest.mock('../shared/components/spinner/spinner', () => {
  const Spinner = () => <div data-testid="loading-spinner">Loading...</div>;
  return Spinner;
});

jest.mock('../shared/components/model/dynamic-model', () => {
  const DynamicModel = ({ errorList }) => (
    <div data-testid="dynamic-error-model">
      Dynamic Error Model
      <pre data-testid="error-list">{JSON.stringify(errorList)}</pre>
    </div>
  );
  return DynamicModel;
});

jest.mock('../shared/components/model/idle-time-out', () => {
  const IdleTimeOutModel = ({ handlePopUpClick }) => (
    <div data-testid="idle-timeout-modal">
      <span>Session Timeout Warning</span>
      <button onClick={handlePopUpClick} data-testid="idle-close-button">
        Continue Session
      </button>
    </div>
  );
  return IdleTimeOutModel;
});

// Mock ActivityDetector with more control
let mockActivityDetectorProps = {};
jest.mock('react-activity-detector', () => {
  const ActivityDetector = (props) => {
    mockActivityDetectorProps = props;
    
    // Create global functions to trigger callbacks for testing
    if (typeof window !== 'undefined') {
      window.triggerIdle = () => props.onIdle && props.onIdle();
      window.triggerActive = () => props.onActive && props.onActive();
    }
    
    return <div data-testid="activity-detector-mock" />;
  };
  return ActivityDetector;
});

// Mock tracking service
const mockTrackEvents = {
  triggerAdobeEvent: jest.fn(),
};
jest.mock('../services/track-events', () => mockTrackEvents);

// Mock utility functions
jest.mock('../modules/dashboard/fields/fields.utils', () => ({
  submitRequest: jest.fn(),
}));

jest.mock('../utils/store/store', () => ({
  store: {
    getState: jest.fn(),
    dispatch: jest.fn(),
    subscribe: jest.fn(),
  },
}));

// Set environment variable
process.env.REACT_APP_RTOB_APP_IDLE_TIMEOUT_DURATION = '30';

describe('App Component Tests', () => {
  // Create mock reducers
  const loaderReducer = (state = { isFetching: { isFetching: false } }, action) => {
    switch (action.type) {
      case 'SET_LOADING':
        return { isFetching: { isFetching: action.payload } };
      default:
        return state;
    }
  };

  const errorReducer = (state = { errors: [], exceptionList: [] }, action) => {
    switch (action.type) {
      case 'SET_ERRORS':
        return { ...state, errors: action.payload };
      case 'SET_EXCEPTIONS':
        return { ...state, exceptionList: action.payload };
      default:
        return state;
    }
  };

  const rootReducer = combineReducers({
    loader: loaderReducer,
    error: errorReducer,
  });

  const createMockStore = (initialState = {}) => {
    return createStore(rootReducer, initialState);
  };

  const renderAppWithStore = (storeState = {}) => {
    const store = createMockStore(storeState);
    return render(
      <Provider store={store}>
        <App />
      </Provider>
    );
  };

  beforeEach(() => {
    jest.clearAllMocks();
    mockActivityDetectorProps = {};
    
    // Reset window functions
    delete window.triggerIdle;
    delete window.triggerActive;
    
    // Mock window methods
    Object.defineProperty(window, 'addEventListener', {
      value: jest.fn(),
      writable: true,
    });
    
    Object.defineProperty(window, 'removeEventListener', {
      value: jest.fn(),
      writable: true,
    });
  });

  describe('Component Rendering', () => {
    test('should render main components without crashing', () => {
      renderAppWithStore();
      
      expect(screen.getByTestId('main-router')).toBeInTheDocument();
      expect(screen.getByTestId('activity-detector-mock')).toBeInTheDocument();
    });

    test('should not show spinner by default', () => {
      renderAppWithStore();
      
      expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();
    });

    test('should not show error models by default', () => {
      renderAppWithStore();
      
      expect(screen.queryByTestId('error-model')).not.toBeInTheDocument();
      expect(screen.queryByTestId('dynamic-error-model')).not.toBeInTheDocument();
    });
  });

  describe('Loading State', () => {
    test('should show spinner when loading is true', () => {
      const storeState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderAppWithStore(storeState);
      
      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();
    });

    test('should hide spinner when loading is false', () => {
      const storeState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderAppWithStore(storeState);
      
      expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();
    });
  });

  describe('Error Handling', () => {
    test('should show error model when errors exist', () => {
      const storeState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: ['Test error message'],
          exceptionList: [],
        },
      };

      renderAppWithStore(storeState);
      
      expect(screen.getByTestId('error-model')).toBeInTheDocument();
      expect(screen.getByText('Error Model: globalError')).toBeInTheDocument();
    });

    test('should show dynamic model when exception list exists', () => {
      const exceptionList = [{ error_header: 'Test Exception' }];
      const storeState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: [],
          exceptionList,
        },
      };

      renderAppWithStore(storeState);
      
      expect(screen.getByTestId('dynamic-error-model')).toBeInTheDocument();
    });

    test('should call adobe tracking when errors occur', () => {
      const storeState = {
        error: {
          errors: ['Test error'],
          exceptionList: [],
        },
      };

      renderAppWithStore(storeState);
      
      expect(mockTrackEvents.triggerAdobeEvent).toHaveBeenCalledWith('formError');
    });

    test('should call adobe tracking when exceptions have error_header', () => {
      const storeState = {
        error: {
          errors: [],
          exceptionList: { error_header: 'Test Exception Header' },
        },
      };

      renderAppWithStore(storeState);
      
      expect(mockTrackEvents.triggerAdobeEvent).toHaveBeenCalledWith('formError');
    });
  });

  describe('Activity Detection and Idle Timeout', () => {
    test('should configure ActivityDetector with correct props', () => {
      renderAppWithStore();
      
      expect(mockActivityDetectorProps.enabled).toBe(true);
      expect(mockActivityDetectorProps.timeout).toBe(300000); // 30 * 10000
      expect(typeof mockActivityDetectorProps.onIdle).toBe('function');
      expect(typeof mockActivityDetectorProps.onActive).toBe('function');
    });

    test('should show idle timeout modal when user goes idle', async () => {
      renderAppWithStore();
      
      // Trigger idle state
      act(() => {
        if (window.triggerIdle) {
          window.triggerIdle();
        }
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-modal')).toBeInTheDocument();
      });
    });

    test('should not show idle modal when loader is active', async () => {
      const storeState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
      };

      renderAppWithStore(storeState);
      
      // Try to trigger idle when loading
      act(() => {
        if (window.triggerIdle) {
          window.triggerIdle();
        }
      });

      // Wait a bit and ensure modal doesn't appear
      await new Promise(resolve => setTimeout(resolve, 100));
      expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
    });

    test('should close idle modal when continue button is clicked', async () => {
      renderAppWithStore();
      
      // Trigger idle state
      act(() => {
        if (window.triggerIdle) {
          window.triggerIdle();
        }
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-modal')).toBeInTheDocument();
      });

      // Click continue button
      fireEvent.click(screen.getByTestId('idle-close-button'));

      await waitFor(() => {
        expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
      });
    });

    test('should hide idle modal when user becomes active', async () => {
      renderAppWithStore();
      
      // Trigger idle state
      act(() => {
        if (window.triggerIdle) {
          window.triggerIdle();
        }
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-modal')).toBeInTheDocument();
      });

      // Trigger active state
      act(() => {
        if (window.triggerActive) {
          window.triggerActive();
        }
      });

      await waitFor(() => {
        expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
      });
    });
  });

  describe('Context Menu Prevention', () => {
    test('should add context menu event listener on mount', () => {
      renderAppWithStore();
      
      expect(window.addEventListener).toHaveBeenCalledWith(
        'contextmenu',
        expect.any(Function)
      );
    });
  });

  describe('Button Interactions', () => {
    test('should handle error model button click', () => {
      const storeState = {
        error: {
          errors: ['Test error'],
          exceptionList: [],
        },
      };

      renderAppWithStore(storeState);
      
      const errorButton = screen.getByTestId('error-model-button');
      expect(() => fireEvent.click(errorButton)).not.toThrow();
    });
  });

  describe('Combined States', () => {
    test('should show both error model and dynamic model when both errors exist', () => {
      const storeState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: ['Regular error'],
          exceptionList: [{ error_header: 'Exception error' }],
        },
      };

      renderAppWithStore(storeState);
      
      expect(screen.getByTestId('error-model')).toBeInTheDocument();
      expect(screen.getByTestId('dynamic-error-model')).toBeInTheDocument();
    });

    test('should prioritize error model over spinner when both conditions are met', () => {
      const storeState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: ['Test error'],
          exceptionList: [],
        },
      };

      renderAppWithStore(storeState);
      
      expect(screen.getByTestId('error-model')).toBeInTheDocument();
      expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();
    });
  });

  describe('Edge Cases', () => {
    test('should handle empty exception list array', () => {
      const storeState = {
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      expect(() => renderAppWithStore(storeState)).not.toThrow();
      expect(screen.queryByTestId('dynamic-error-model')).not.toBeInTheDocument();
    });

    test('should handle null/undefined states gracefully', () => {
      const storeState = {
        loader: null,
        error: null,
      };

      expect(() => renderAppWithStore(storeState)).not.toThrow();
    });
  });
});
