import React from 'react';
import { render, screen, fireEvent, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import MultiSelectionBox from './MultiSelectionBox';
import { KeyWithAnyModel } from '../../../utils/model/common-model';

// Mock Redux store
const mockStore = configureStore({
  reducer: {
    lov: () => ({
      lov: [
        {
          label: 'test_field',
          value: [
            { CODE_VALUE: 'OPT1', CODE_DESC: 'Option 1', checked: false },
            { CODE_VALUE: 'OPT2', CODE_DESC: 'Option 2', checked: false },
            { CODE_VALUE: 'OPT3', CODE_DESC: 'Option 3', checked: false },
          ]
        }
      ]
    }),
    fielderror: () => ({ error: [] }),
    stages: () => ({
      stages: [
        {
          stageId: 'test-stage',
          stageInfo: {
            applicants: {
              'test_field_a_1': 'OPT1,OPT2'
            }
          }
        }
      ],
      myinfoResponse: {}
    }),
    lastAccessed: () => ({})
  }
});

// Mock dispatch
const mockDispatch = jest.fn();
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useDispatch: () => mockDispatch,
  useSelector: jest.fn()
}));

describe('MultiSelectionBox Component', () => {
  const mockProps: KeyWithAnyModel = {
    data: {
      logical_field_name: 'test_field',
      rwb_label_name: 'Test Field',
      mandatory: 'Yes',
      max_selects: '2',
      editable: true
    },
    handleCallback: jest.fn()
  };

  beforeEach(() => {
    jest.clearAllMocks();
    // Mock useSelector implementation
    require('react-redux').useSelector.mockImplementation((selector) => selector(mockStore.getState()));
  });

  it('renders without crashing', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    expect(screen.getByText('Test Field')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('Test Field')).toBeInTheDocument();
  });

  it('displays pre-selected values', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    expect(screen.getByText('Option 1')).toBeInTheDocument();
    expect(screen.getByText('Option 2')).toBeInTheDocument();
  });

  it('opens dropdown when clicked', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    fireEvent.click(screen.getByPlaceholderText('Test Field'));
    expect(screen.getByText('Continue')).toBeInTheDocument();
  });

  it('closes dropdown when close button is clicked', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    fireEvent.click(screen.getByPlaceholderText('Test Field'));
    fireEvent.click(screen.getByTestId('close'));
    expect(screen.queryByText('Continue')).not.toBeInTheDocument();
  });

  it('allows selecting options', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    fireEvent.click(screen.getByPlaceholderText('Test Field'));
    const option3Checkbox = screen.getByLabelText('Option 3');
    fireEvent.click(option3Checkbox);
    
    expect(option3Checkbox).toBeChecked();
  });

  it('shows error when mandatory field is empty', () => {
    const testProps = { ...mockProps };
    testProps.data.mandatory = 'Yes';
    
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...testProps} />
      </Provider>
    );
    
    // Remove all selected options
    const option1Close = screen.getByText('Option 1').nextElementSibling;
    const option2Close = screen.getByText('Option 2').nextElementSibling;
    
    if (option1Close) fireEvent.click(option1Close);
    if (option2Close) fireEvent.click(option2Close);
    
    expect(screen.getByText('Please enter Test Field')).toBeInTheDocument();
  });

  it('enforces max selection limit', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    fireEvent.click(screen.getByPlaceholderText('Test Field'));
    
    // Select two options (already has two selected)
    const option3Checkbox = screen.getByLabelText('Option 3');
    fireEvent.click(option3Checkbox);
    
    expect(screen.getByText(/You have selected maximum options for/)).toBeInTheDocument();
  });

  it('handles search functionality', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    fireEvent.click(screen.getByPlaceholderText('Test Field'));
    const searchInput = screen.getByPlaceholderText('Search');
    fireEvent.change(searchInput, { target: { value: 'Option 1' } });
    
    expect(screen.getByLabelText('Option 1')).toBeInTheDocument();
    expect(screen.queryByLabelText('Option 2')).not.toBeInTheDocument();
  });

  it('dispatches actions when values change', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    // Remove an option
    const option1Close = screen.getByText('Option 1').nextElementSibling;
    if (option1Close) fireEvent.click(option1Close);
    
    expect(mockDispatch).toHaveBeenCalled();
  });

  it('handles continue button click', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    fireEvent.click(screen.getByPlaceholderText('Test Field'));
    fireEvent.click(screen.getByText('Continue'));
    
    expect(screen.queryByText('Continue')).not.toBeInTheDocument();
  });

  it('disables field when isMyinfo is true or editable is false', () => {
    const testProps = { ...mockProps };
    testProps.data.editable = false;
    
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...testProps} />
      </Provider>
    );
    
    expect(screen.getByPlaceholderText('Test Field').closest('div')).toHaveClass('disabled');
  });

  it('handles special case for select_alt_addresses', () => {
    const customStore = configureStore({
      reducer: {
        lov: () => ({
          lov: [
            {
              label: 'select_alt_addresses',
              value: [
                { CODE_VALUE: 'PER', CODE_DESC: 'Permanent', checked: false },
                { CODE_VALUE: 'OTH', CODE_DESC: 'Other', checked: false }
              ]
            }
          ]
        }),
        stages: () => ({
          stages: [
            {
              stageId: 'test-stage',
              stageInfo: {
                applicants: {
                  'permanent_address_rwb_1_a_1': 'Test Address',
                  'select_alt_addresses_a_1': 'PER'
                }
              }
            }
          ]
        }),
        // Other reducers...
      }
    });
    
    const testProps = { 
      ...mockProps,
      data: {
        ...mockProps.data,
        logical_field_name: 'select_alt_addresses'
      }
    };
    
    render(
      <Provider store={customStore}>
        <MultiSelectionBox {...testProps} />
      </Provider>
    );
    
    fireEvent.click(screen.getByPlaceholderText('Test Field'));
    expect(screen.queryByLabelText('Permanent')).not.toBeInTheDocument();
  });

  it('handles field focus', () => {
    render(
      <Provider store={mockStore}>
        <MultiSelectionBox {...mockProps} />
      </Provider>
    );
    
    const input = screen.getByPlaceholderText('Test Field');
    fireEvent.focus(input);
    
    expect(mockDispatch).toHaveBeenCalledWith(
      expect.objectContaining({
        type: 'lastAccessed/getField',
        payload: 'test_field'
      })
    );
  });
});
