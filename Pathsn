import { render, screen, waitFor, act, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { MemoryRouter } from 'react-router-dom';
import Dashboard from './Dashboard';
import configureStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import * as changeUtils from '../../utils/common/change.utils';
import * as commonService from '../../services/common-service';

// Mock child components
jest.mock('./header/header', () => () => <div>Header Component</div>);
jest.mock('./fields/fields', () => () => <div>Fields Component</div>);
jest.mock('../../shared/components/myinfo-singpass-login-modal/myinfo-singpass-login', () => () => <div>MyInfoSingpassLogin Component</div>);
jest.mock('../../shared/components/popup-model/popup-model', () => ({ children, displayPopup }: any) => 
  displayPopup ? <div>{children}</div> : null
);
jest.mock('../../shared/components/model/model', () => ({ name, handlebuttonClick }: any) => 
  <div>
    {name} Model Component
    <button onClick={handlebuttonClick}>Close</button>
  </div>
);

const middlewares = [thunk];
const mockStore = configureStore(middlewares);

describe('Dashboard Component', () => {
  let store: any;
  const mockDispatch = jest.fn();
  const mockNavigate = jest.fn();

  beforeEach(() => {
    store = mockStore({
      stages: {
        stages: [],
        otpOpen: false,
        otpResume: false
      },
      urlParam: {
        myInfo: false,
        validUrl: true
      },
      referralcode: {}
    });

    jest.spyOn(commonService, 'getClientInfo').mockResolvedValue({});
    jest.spyOn(changeUtils, 'authenticateType').mockReturnValue('default');
    jest.spyOn(changeUtils, 'getUrl').mockReturnValue({
      getLoader: () => ({ cta: { cta: false } })
    });

    jest.mock('react-redux', () => ({
      ...jest.requireActual('react-redux'),
      useDispatch: () => mockDispatch,
      useSelector: jest.fn()
    }));

    jest.mock('react-router-dom', () => ({
      ...jest.requireActual('react-router-dom'),
      useNavigate: () => mockNavigate,
      useLocation: () => ({ pathname: '/test' })
    }));
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  const renderDashboard = () => {
    return render(
      <Provider store={store}>
        <MemoryRouter>
          <Dashboard />
        </MemoryRouter>
      </Provider>
    );
  };

  it('renders without crashing', () => {
    renderDashboard();
    expect(screen.queryByText('Header Component')).not.toBeInTheDocument();
  });

  it('displays global error popup when url is invalid', async () => {
    store = mockStore({
      ...store.getState(),
      urlParam: { validUrl: false }
    });

    renderDashboard();
    await waitFor(() => {
      expect(screen.getByText('globalError Model Component')).toBeInTheDocument();
    });
  });

  it('displays MyInfoSingpassLogin when myInfo is true', async () => {
    store = mockStore({
      ...store.getState(),
      urlParam: { myInfo: true }
    });

    renderDashboard();
    await waitFor(() => {
      expect(screen.getByText('MyInfoSingpassLogin Component')).toBeInTheDocument();
    });
  });

  it('displays confirmation popup when authenticateType is myinfo', async () => {
    (changeUtils.authenticateType as jest.Mock).mockReturnValue('myinfo');
    
    renderDashboard();
    await waitFor(() => {
      expect(screen.getByText('confirmationPopup Model Component')).toBeInTheDocument();
    });
  });

  it('closes confirmation popup when handlePopupBackButton is called', async () => {
    (changeUtils.authenticateType as jest.Mock).mockReturnValue('myinfo');
    
    renderDashboard();
    await waitFor(() => {
      const closeButton = screen.getByText('Close');
      fireEvent.click(closeButton);
      expect(screen.queryByText('confirmationPopup Model Component')).not.toBeInTheDocument();
    });
  });

  it('renders Header and Fields components when conditions are met', async () => {
    store = mockStore({
      ...store.getState(),
      stages: { stages: [{ stageId: 'test' }], otpOpen: false }
    });

    renderDashboard();
    await waitFor(() => {
      expect(screen.getByText('Header Component')).toBeInTheDocument();
      expect(screen.getByText('Fields Component')).toBeInTheDocument();
    });
  });

  it('handles window resize events', async () => {
    renderDashboard();
    
    act(() => {
      window.innerWidth = 500;
      window.dispatchEvent(new Event('resize'));
    });

    // We can't directly test the state change, but we can verify the component doesn't crash
    await waitFor(() => {
      expect(screen.queryByText('Header Component')).not.toBeInTheDocument();
    });
  });

  it('sets pointer-none class when ctaLoader.cta is true', async () => {
    (changeUtils.getUrl as jest.Mock).mockReturnValue({
      getLoader: () => ({ cta: { cta: true } })
    });

    store = mockStore({
      ...store.getState(),
      stages: { stages: [{ stageId: 'test' }], otpOpen: false }
    });

    renderDashboard();
    await waitFor(() => {
      const appBody = screen.getByText('Fields Component').closest('.app__body');
      expect(appBody).toHaveClass('pointer-none');
    });
  });

  it('navigates to super-short-form when url is valid and not myinfo', async () => {
    renderDashboard();
    await waitFor(() => {
      expect(mockNavigate).toHaveBeenCalledWith('sg/super-short-form');
    });
  });

  it('dispatches correct actions on mount', async () => {
    renderDashboard();
    await waitFor(() => {
      expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'loader/getState'
      }));
      expect(mockDispatch).toHaveBeenCalledWith(expect.objectContaining({
        type: 'urlParam/getUrlParameter'
      }));
      expect(commonService.getClientInfo).toHaveBeenCalled();
    });
  });
});
