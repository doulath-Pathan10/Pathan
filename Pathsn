import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import DocumentUpload from './DocumentUpload';
import { Provider } from 'react-redux';
import { store } from '../../../utils/store/store';
import axios from 'axios';

// Mock axios and other dependencies
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

// Mock other dependencies
jest.mock('../../../services/track-events');
jest.mock('../../../utils/common/change.utils');
jest.mock('../../../services/common-service');

describe('DocumentUpload Component', () => {
  const mockProps = {
    backHandler: jest.fn(),
  };

  const mockDocumentResponse = [
    {
      document_list: [
        {
          document_category_code: 'ID',
          document_category: 'Identification',
          docCheck: 'N',
          isSlectedForUpload: 'N',
          document_options: [
            {
              document_types: [
                {
                  document_type_code: 'R0001',
                  document_type: 'NRIC',
                  uploaded_documents: [],
                  selectDocument: null,
                },
              ],
            },
          ],
        },
      ],
      isSignatureDoc: false,
    },
  ];

  beforeEach(() => {
    // Reset store and mocks before each test
    store.dispatch({ type: 'RESET' });
    jest.clearAllMocks();

    // Mock store state
    store.dispatch({
      type: 'documentUploadList/getDocumentList',
      payload: {
        responseDocuments: mockDocumentResponse,
      },
    });

    store.dispatch({
      type: 'stages/getStage',
      payload: {
        id: 'doc',
        stageInfo: {
          applicant_documents: mockDocumentResponse,
          application: {
            channel_reference: 'TEST123',
            application_reference: 'APP123',
          },
          applicants: {},
          products: [{ product_category: 'CC' }],
        },
      },
    });
  });

  test('renders without crashing', () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    expect(screen.getByText(/Upload your identification/i)).toBeInTheDocument();
  });

  test('displays document headers correctly', () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    expect(screen.getByText('Upload your identification')).toBeInTheDocument();
  });

  test('shows radio button options when document is not selected for upload', () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    expect(screen.getByLabelText('NRIC')).toBeInTheDocument();
    expect(screen.getByText('Upload')).toBeInTheDocument();
  });

  test('changes to upload view when upload button is clicked', () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    const uploadButton = screen.getByText('Upload');
    fireEvent.click(uploadButton);

    expect(screen.getByText('Upload your nric')).toBeInTheDocument();
  });

  test('handles file selection and upload', async () => {
    const mockFile = new File(['test'], 'test.png', { type: 'image/png' });
    mockedAxios.post.mockResolvedValueOnce({
      data: { docId: 'DOC123', documentStatus: 'Accepted' },
    });

    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    // Click upload button to show file input
    const uploadButton = screen.getByText('Upload');
    fireEvent.click(uploadButton);

    // Simulate file selection
    const fileInput = screen.getByTestId('file-input');
    await act(async () => {
      fireEvent.change(fileInput, { target: { files: [mockFile] } });
    });

    // Check if axios was called
    await waitFor(() => {
      expect(mockedAxios.post).toHaveBeenCalled();
    });
  });

  test('shows error when trying to upload without selecting document', () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    // Click upload button without selecting a document
    const uploadButton = screen.getByText('Upload');
    fireEvent.click(uploadButton);

    // Error popup should appear
    expect(screen.getByText(/Please select a document/i)).toBeInTheDocument();
  });

  test('handles file upload error', async () => {
    const mockFile = new File(['test'], 'test.png', { type: 'image/png' });
    mockedAxios.post.mockRejectedValueOnce(new Error('Upload failed'));

    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    // Click upload button to show file input
    const uploadButton = screen.getByText('Upload');
    fireEvent.click(uploadButton);

    // Simulate file selection
    const fileInput = screen.getByTestId('file-input');
    await act(async () => {
      fireEvent.change(fileInput, { target: { files: [mockFile] } });
    });

    // Check if error state is shown
    await waitFor(() => {
      expect(screen.getByText(/Upload failed/i)).toBeInTheDocument();
    });
  });

  test('submits documents when continue button is clicked', async () => {
    // Mock successful document submission
    store.dispatch({
      type: 'documentUploadList/getDocumentList',
      payload: {
        responseDocuments: [
          {
            document_list: [
              {
                document_category_code: 'ID',
                document_category: 'Identification',
                docCheck: 'Y',
                isSlectedForUpload: 'Y',
                document_options: [
                  {
                    document_types: [
                      {
                        document_type_code: 'R0001',
                        document_type: 'NRIC',
                        uploaded_documents: [
                          {
                            docId: 'DOC123',
                            documentStatus: 'Accepted',
                          },
                        ],
                        selectDocument: 'NRIC',
                      },
                    ],
                  },
                ],
              },
            ],
            isSignatureDoc: false,
          },
        ],
      },
    });

    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    // Click continue button
    const continueButton = screen.getByText('Continue');
    fireEvent.click(continueButton);

    // Check if submission process was initiated
    await waitFor(() => {
      expect(mockedAxios.post).toHaveBeenCalled();
    });
  });

  test('shows error when mandatory documents are missing', () => {
    // Set mandatory documents in store
    store.dispatch({
      type: 'documentUploadList/getDocumentList',
      payload: {
        responseDocuments: mockDocumentResponse,
      },
    });

    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    // Click continue button without uploading mandatory docs
    const continueButton = screen.getByText('Continue');
    fireEvent.click(continueButton);

    // Error popup should appear
    expect(
      screen.getByText(/Please upload all mandatory documents/i)
    ).toBeInTheDocument();
  });

  test('handles back button click', () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    const backButton = screen.getByText('Back');
    fireEvent.click(backButton);

    expect(mockProps.backHandler).toHaveBeenCalled();
  });

  test('displays file specifications correctly', () => {
    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    expect(
      screen.getByText(/Please ensure that the attached file/i)
    ).toBeInTheDocument();
    expect(screen.getByText(/JPG, PNG, TIFF, and PDF formats/i)).toBeInTheDocument();
    expect(screen.getByText(/less than 10 MB/i)).toBeInTheDocument();
  });

  test('displays signature specimen note when isSignatureDoc is true', () => {
    // Update store with signature doc
    store.dispatch({
      type: 'documentUploadList/getDocumentList',
      payload: {
        responseDocuments: [
          {
            ...mockDocumentResponse[0],
            isSignatureDoc: true,
          },
        ],
      },
    });

    render(
      <Provider store={store}>
        <DocumentUpload {...mockProps} />
      </Provider>
    );

    expect(
      screen.getByText(/I confirm that the electronic image of my signature/i)
    ).toBeInTheDocument();
  });
});
