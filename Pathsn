import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import '@testing-library/jest-dom';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import App from './App';

// Create mock store
const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

// Mock all modules before importing App
jest.mock('./router/main', () => {
  return jest.fn(() => <div data-testid="main-component">Main Component</div>);
});

jest.mock('./shared/components/model/model', () => {
  return jest.fn(({ name, handlebuttonClick }) => (
    <div data-testid="global-error-model">
      <span>Global Error Model</span>
      <button onClick={handlebuttonClick} data-testid="global-error-button">
        Close
      </button>
    </div>
  ));
});

jest.mock('./shared/components/spinner/spinner', () => {
  return jest.fn(() => <div data-testid="spinner">Loading Spinner</div>);
});

jest.mock('./shared/components/model/dynamic-model', () => {
  return jest.fn(({ errorList }) => (
    <div data-testid="dynamic-model">
      <span>Dynamic Model</span>
      <div data-testid="error-list">{JSON.stringify(errorList)}</div>
    </div>
  ));
});

jest.mock('./shared/components/model/idle-time-out', () => {
  return jest.fn(({ handlePopUpClick }) => (
    <div data-testid="idle-timeout-modal">
      <span>Idle Timeout Modal</span>
      <button onClick={handlePopUpClick} data-testid="idle-continue-btn">
        Continue
      </button>
    </div>
  ));
});

// Mock ActivityDetector with proper callback handling
let activityCallbacks = {};
jest.mock('react-activity-detector', () => {
  return jest.fn((props) => {
    activityCallbacks = {
      onIdle: props.onIdle,
      onActive: props.onActive,
      enabled: props.enabled,
      timeout: props.timeout,
    };
    
    return <div data-testid="activity-detector">Activity Detector</div>;
  });
});

// Mock services
const mockTrackEvents = {
  triggerAdobeEvent: jest.fn(),
};
jest.mock('./services/track-events', () => mockTrackEvents);

jest.mock('./modules/dashboard/fields/fields.utils', () => ({
  submitRequest: jest.fn(),
}));

jest.mock('./utils/store/store', () => ({
  store: {
    getState: jest.fn(),
    dispatch: jest.fn(),
  },
}));

// Mock environment variable
process.env.REACT_APP_RTOB_APP_IDLE_TIMEOUT_DURATION = '5';

// Helper function to render component with store
const renderWithStore = (initialState = {}) => {
  const defaultState = {
    loader: {
      isFetching: {
        isFetching: false,
      },
    },
    error: {
      errors: [],
      exceptionList: [],
    },
    ...initialState,
  };

  const store = mockStore(defaultState);
  
  return {
    ...render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    ),
    store,
  };
};

describe('App Component', () => {
  let mockAddEventListener;
  let mockRemoveEventListener;

  beforeEach(() => {
    jest.clearAllMocks();
    activityCallbacks = {};
    
    // Mock window event listeners
    mockAddEventListener = jest.fn();
    mockRemoveEventListener = jest.fn();
    
    Object.defineProperty(window, 'addEventListener', {
      value: mockAddEventListener,
      writable: true,
    });
    
    Object.defineProperty(window, 'removeEventListener', {
      value: mockRemoveEventListener,
      writable: true,
    });
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  describe('Basic Rendering', () => {
    it('renders without crashing', () => {
      renderWithStore();
      expect(screen.getByTestId('main-component')).toBeInTheDocument();
    });

    it('renders activity detector with correct configuration', () => {
      renderWithStore();
      
      expect(screen.getByTestId('activity-detector')).toBeInTheDocument();
      expect(activityCallbacks.enabled).toBe(true);
      expect(activityCallbacks.timeout).toBe(50000); // 5 * 10000
    });

    it('does not render any modals by default', () => {
      renderWithStore();
      
      expect(screen.queryByTestId('global-error-model')).not.toBeInTheDocument();
      expect(screen.queryByTestId('dynamic-model')).not.toBeInTheDocument();
      expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
      expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
    });
  });

  describe('Context Menu Prevention', () => {
    it('adds contextmenu event listener on mount', () => {
      renderWithStore();
      
      expect(mockAddEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function));
    });

    it('removes contextmenu event listener on unmount', () => {
      const { unmount } = renderWithStore();
      
      unmount();
      
      expect(mockRemoveEventListener).toHaveBeenCalledWith('contextmenu', expect.any(Function));
    });
  });

  describe('Loading State', () => {
    it('shows spinner when loading is true and no errors', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderWithStore(initialState);
      
      expect(screen.getByTestId('spinner')).toBeInTheDocument();
    });

    it('does not show spinner when loading is false', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderWithStore(initialState);
      
      expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
    });

    it('does not show spinner when there are errors even if loading', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
        error: {
          errors: ['Some error'],
          exceptionList: [],
        },
      };

      renderWithStore(initialState);
      
      expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
      expect(screen.getByTestId('global-error-model')).toBeInTheDocument();
    });
  });

  describe('Error Handling', () => {
    it('shows global error model when errors exist', () => {
      const initialState = {
        error: {
          errors: ['Error message 1', 'Error message 2'],
          exceptionList: [],
        },
      };

      renderWithStore(initialState);
      
      expect(screen.getByTestId('global-error-model')).toBeInTheDocument();
    });

    it('shows dynamic model when exception list has items', () => {
      const exceptionList = [{ type: 'validation', message: 'Field required' }];
      const initialState = {
        error: {
          errors: [],
          exceptionList,
        },
      };

      renderWithStore(initialState);
      
      expect(screen.getByTestId('dynamic-model')).toBeInTheDocument();
      expect(screen.getByTestId('error-list')).toHaveTextContent(JSON.stringify(exceptionList));
    });

    it('shows both models when both errors and exceptions exist', () => {
      const initialState = {
        error: {
          errors: ['Global error'],
          exceptionList: [{ type: 'exception' }],
        },
      };

      renderWithStore(initialState);
      
      expect(screen.getByTestId('global-error-model')).toBeInTheDocument();
      expect(screen.getByTestId('dynamic-model')).toBeInTheDocument();
    });

    it('triggers adobe event when errors are present', () => {
      const initialState = {
        error: {
          errors: ['Test error'],
          exceptionList: [],
        },
      };

      renderWithStore(initialState);
      
      expect(mockTrackEvents.triggerAdobeEvent).toHaveBeenCalledWith('formError');
    });

    it('triggers adobe event when exception list has error_header', () => {
      const initialState = {
        error: {
          errors: [],
          exceptionList: { error_header: 'Exception header' },
        },
      };

      renderWithStore(initialState);
      
      expect(mockTrackEvents.triggerAdobeEvent).toHaveBeenCalledWith('formError');
    });

    it('does not trigger adobe event when no errors', () => {
      renderWithStore();
      
      expect(mockTrackEvents.triggerAdobeEvent).not.toHaveBeenCalled();
    });
  });

  describe('Idle Functionality', () => {
    it('shows idle modal when user goes idle and not loading', async () => {
      renderWithStore();
      
      act(() => {
        if (activityCallbacks.onIdle) {
          activityCallbacks.onIdle();
        }
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-modal')).toBeInTheDocument();
      });
    });

    it('does not show idle modal when loading is active', async () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: true,
          },
        },
      };

      renderWithStore(initialState);
      
      act(() => {
        if (activityCallbacks.onIdle) {
          activityCallbacks.onIdle();
        }
      });

      // Wait a moment and ensure modal doesn't appear
      await act(async () => {
        await new Promise(resolve => setTimeout(resolve, 100));
      });

      expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
    });

    it('hides idle modal when user becomes active', async () => {
      renderWithStore();
      
      // Trigger idle first
      act(() => {
        if (activityCallbacks.onIdle) {
          activityCallbacks.onIdle();
        }
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-modal')).toBeInTheDocument();
      });

      // Then trigger active
      act(() => {
        if (activityCallbacks.onActive) {
          activityCallbacks.onActive();
        }
      });

      await waitFor(() => {
        expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
      });
    });

    it('closes idle modal when continue button is clicked', async () => {
      renderWithStore();
      
      // Trigger idle
      act(() => {
        if (activityCallbacks.onIdle) {
          activityCallbacks.onIdle();
        }
      });

      await waitFor(() => {
        expect(screen.getByTestId('idle-timeout-modal')).toBeInTheDocument();
      });

      // Click continue button
      fireEvent.click(screen.getByTestId('idle-continue-btn'));

      await waitFor(() => {
        expect(screen.queryByTestId('idle-timeout-modal')).not.toBeInTheDocument();
      });
    });
  });

  describe('Button Interactions', () => {
    it('handles global error model button click without crashing', () => {
      const initialState = {
        error: {
          errors: ['Test error'],
          exceptionList: [],
        },
      };

      renderWithStore(initialState);
      
      const button = screen.getByTestId('global-error-button');
      
      expect(() => {
        fireEvent.click(button);
      }).not.toThrow();
    });
  });

  describe('Edge Cases and Error Boundaries', () => {
    it('handles undefined loader state gracefully', () => {
      const initialState = {
        loader: undefined,
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      expect(() => {
        renderWithStore(initialState);
      }).not.toThrow();
    });

    it('handles undefined error state gracefully', () => {
      const initialState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: undefined,
      };

      expect(() => {
        renderWithStore(initialState);
      }).not.toThrow();
    });

    it('handles null isFetching object', () => {
      const initialState = {
        loader: {
          isFetching: null,
        },
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      expect(() => {
        renderWithStore(initialState);
      }).not.toThrow();
    });

    it('handles empty exception list array correctly', () => {
      const initialState = {
        error: {
          errors: [],
          exceptionList: [],
        },
      };

      renderWithStore(initialState);
      
      expect(screen.queryByTestId('dynamic-model')).not.toBeInTheDocument();
    });
  });

  describe('State Changes and Re-renders', () => {
    it('updates UI when store state changes', () => {
      const { store } = renderWithStore();
      
      // Initially no spinner
      expect(screen.queryByTestId('spinner')).not.toBeInTheDocument();
      
      // Simulate store state change by dispatching action
      store.dispatch({ type: 'MOCK_ACTION' });
      
      // Component should still be stable
      expect(screen.getByTestId('main-component')).toBeInTheDocument();
    });
  });

  describe('Window Event Handling', () => {
    it('adds unload event listener', () => {
      renderWithStore();
      
      expect(mockAddEventListener).toHaveBeenCalledWith('unload', expect.any(Function));
    });
  });

  describe('Environment Configuration', () => {
    it('uses correct timeout value from environment', () => {
      renderWithStore();
      
      expect(activityCallbacks.timeout).toBe(50000);
    });
  });

  describe('Integration Tests', () => {
    it('renders all components together in complex state', () => {
      const complexState = {
        loader: {
          isFetching: {
            isFetching: false,
          },
        },
        error: {
          errors: ['Global error'],
          exceptionList: [{ type: 'validation', field: 'email' }],
        },
      };

      renderWithStore(complexState);
      
      expect(screen.getByTestId('main-component')).toBeInTheDocument();
      expect(screen.getByTestId('activity-detector')).toBeInTheDocument();
      expect(screen.getByTestId('global-error-model')).toBeInTheDocument();
      expect(screen.getByTestId('dynamic-model')).toBeInTheDocument();
    });

    it('handles rapid state changes without crashing', async () => {
      renderWithStore();
      
      // Rapid idle/active changes
      for (let i = 0; i < 5; i++) {
        act(() => {
          if (activityCallbacks.onIdle) {
            activityCallbacks.onIdle();
          }
        });
        
        act(() => {
          if (activityCallbacks.onActive) {
            activityCallbacks.onActive();
          }
        });
      }
      
      // Should still render main component
      expect(screen.getByTestId('main-component')).toBeInTheDocument();
    });
  });
});
