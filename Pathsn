// Add these to your existing mock setup
jest.mock('react-redux', () => ({
  ...jest.requireActual('react-redux'),
  useDispatch: () => jest.fn(),
  useSelector: jest.fn(),
}));

jest.mock('../../store/preApproval-slice', () => ({
  preApprovalAction: {
    setKfsDocumentPdf: jest.fn(),
    setCurrentStage: jest.fn(),
  },
}));

jest.mock('../../../../utils/store/stages-slice', () => ({
  stagesAction: {
    updateStageId: jest.fn(),
  },
}));

jest.mock('../../services/common-service', () => ({
  dispatchLoader: jest.fn(),
  lovRequests: jest.fn(),
}));

test('displays Chinese content when language is zh', async () => {
  (getUrl.getLanguageInfo as jest.Mock).mockReturnValue('zh');
  renderComponent();
  
  await waitFor(() => {
    expect(screen.getByText(/Download/i)).toBeInTheDocument();
    // Add more assertions for Chinese specific content
  });
});

test('displays Hong Kong content when language is hk', async () => {
  (getUrl.getLanguageInfo as jest.Mock).mockReturnValue('hk');
  renderComponent();
  
  await waitFor(() => {
    expect(screen.getByText(/Download/i)).toBeInTheDocument();
    // Add more assertions for HK specific content
  });
});


test('renders English PDF by default', async () => {
  renderComponent();
  
  await waitFor(() => {
    expect(screen.getByText('Mock PDF Component')).toBeInTheDocument();
  });
});

test('renders Chinese PDF when language is zh', async () => {
  (getUrl.getLanguageInfo as jest.Mock).mockReturnValue('zh');
  renderComponent();
  
  await waitFor(() => {
    expect(screen.getByText('Mock PDF Component')).toBeInTheDocument();
  });
});


test('shows accept button when scrolled to bottom', async () => {
  renderComponent();
  
  const scrollContainer = screen.getByRole('region'); // Or use a test id
  Object.defineProperty(scrollContainer, 'scrollHeight', { value: 1000 });
  Object.defineProperty(scrollContainer, 'clientHeight', { value: 500 });
  Object.defineProperty(scrollContainer, 'scrollTop', { value: 500 });
  
  fireEvent.scroll(scrollContainer);
  
  await waitFor(() => {
    expect(screen.getByText(/I ACCEPT/i)).toBeInTheDocument();
  });
});

test('does not show accept button when not scrolled to bottom', async () => {
  renderComponent();
  
  const scrollContainer = screen.getByRole('region');
  Object.defineProperty(scrollContainer, 'scrollHeight', { value: 1000 });
  Object.defineProperty(scrollContainer, 'clientHeight', { value: 500 });
  Object.defineProperty(scrollContainer, 'scrollTop', { value: 100 });
  
  fireEvent.scroll(scrollContainer);
  
  await waitFor(() => {
    expect(screen.queryByText(/I ACCEPT/i)).not.toBeInTheDocument();
    expect(screen.getByText(/TAP TO SCROLL/i)).toBeInTheDocument();
  });
});


test('dispatches correct actions when accept button is clicked', async () => {
  renderComponent();
  
  // Mock scroll to bottom to show accept button
  const scrollContainer = screen.getByRole('region');
  Object.defineProperties(scrollContainer, {
    scrollHeight: { value: 1000 },
    clientHeight: { value: 500 },
    scrollTop: { value: 500 },
  });
  fireEvent.scroll(scrollContainer);
  
  const acceptButton = await screen.findByText(/I ACCEPT/i);
  fireEvent.click(acceptButton);
  
  // Verify Redux actions were dispatched
  const actions = store.getActions();
  expect(actions.some(action => action.type === 'stages/updateStageId')).toBeTruthy();
  expect(actions.some(action => action.type === 'preApproval/setCurrentStage')).toBeTruthy();
});

test('downloadPDFPreApproval creates correct anchor element for Safari', () => {
  // Mock Safari user agent
  Object.defineProperty(window.navigator, 'userAgent', {
    value: 'Safari',
    writable: true,
  });
  
  renderComponent();
  
  const downloadButton = screen.getByText(/Download/i);
  const createElementSpy = jest.spyOn(document, 'createElement');
  const appendChildSpy = jest.spyOn(document.body, 'appendChild');
  const removeChildSpy = jest.spyOn(document.body, 'removeChild');
  
  fireEvent.click(downloadButton);
  
  expect(createElementSpy).toHaveBeenCalledWith('a');
  expect(appendChildSpy).toHaveBeenCalled();
  expect(removeChildSpy).toHaveBeenCalled();
  
  // Clean up
  createElementSpy.mockRestore();
  appendChildSpy.mockRestore();
  removeChildSpy.mockRestore();
});

test('downloadPDFPreApproval creates correct anchor element for non-Safari', () => {
  // Mock non-Safari user agent
  Object.defineProperty(window.navigator, 'userAgent', {
    value: 'Chrome',
    writable: true,
  });
  
  renderComponent();
  
  const downloadButton = screen.getByText(/Download/i);
  const createElementSpy = jest.spyOn(document, 'createElement');
  
  fireEvent.click(downloadButton);
  
  expect(createElementSpy).toHaveBeenCalledWith('a');
  // Add more assertions for non-Safari behavior
});

test('renders differently when stageID is provided', () => {
  renderComponent({ stageID: 1 });
  
  // Add assertions for how the component should look with stageID
  expect(screen.getByText('Loading...')).toBeInTheDocument();
});

test('renders differently when stageID is provided', () => {
  renderComponent({ stageID: 1 });
  
  // Add assertions for how the component should look with stageID
  expect(screen.getByText('Loading...')).toBeInTheDocument();
});

test('handles API errors gracefully', async () => {
  require('../../services/preApprovalServices').getData.mockRejectedValue(new Error('API Error'));
  
  renderComponent();
  
  await waitFor(() => {
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    // Add more assertions for error state
  });
});

test('cleans up event listeners on unmount', () => {
  const { unmount } = renderComponent();
  const scrollContainer = screen.getByRole('region');
  const removeListenerSpy = jest.spyOn(scrollContainer, 'removeEventListener');
  
  unmount();
  
  expect(removeListenerSpy).toHaveBeenCalledWith('scroll', expect.any(Function));
});

