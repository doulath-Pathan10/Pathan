import React from 'react';
import { render, screen, act } from '@testing-library/react';
import { Provider } from 'react-redux';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import store from './utils/store/store';

// Mock components and libraries
jest.mock('./router/main', () => () => <div>Main Component</div>);
jest.mock('./shared/components/model/model', () => () => <div>Model Component</div>);
jest.mock('./shared/components/spinner/spinner', () => () => <div>Spinner Component</div>);
jest.mock('./shared/components/model/dynamic-model', () => () => <div>DynamicModel Component</div>);
jest.mock('./shared/components/model/idle-time-out', () => ({ handlePopUpClick }: any) => (
  <div>
    IdleTimeOutModel Component
    <button onClick={handlePopUpClick}>Close</button>
  </div>
));
jest.mock('react-activity-detector', () => ({
  __esModule: true,
  default: ({ onIdle, onActive }: any) => {
    // Simulate activity detector behavior
    React.useEffect(() => {
      const timer = setTimeout(() => onIdle(), 100);
      return () => clearTimeout(timer);
    }, [onIdle]);
    return null;
  },
}));
jest.mock('./services/track-events', () => ({
  triggerAdobeEvent: jest.fn(),
}));

describe('App Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders without crashing', () => {
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    expect(screen.getByText('Main Component')).toBeInTheDocument();
  });

  it('disables right click context menu', () => {
    const addEventListenerSpy = jest.spyOn(window, 'addEventListener');
    const removeEventListenerSpy = jest.spyOn(window, 'removeEventListener');
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(addEventListenerSpy).toHaveBeenCalledWith('contextmenu', expect.any(Function));
    
    // Cleanup
    const { unmount } = render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    unmount();
    expect(removeEventListenerSpy).toHaveBeenCalledWith('contextmenu', expect.any(Function));
  });

  it('shows spinner when loaderState is true', () => {
    // Mock useSelector to return loader state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: true } },
      error: { errors: [], exceptionList: [] },
    }));
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByText('Spinner Component')).toBeInTheDocument();
  });

  it('shows error model when errors exist', () => {
    // Mock useSelector to return error state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { errors: ['Test error'], exceptionList: [] },
    }));
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByText('Model Component')).toBeInTheDocument();
  });

  it('shows dynamic model when exceptionList exists', () => {
    // Mock useSelector to return exception state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { errors: [], exceptionList: [{ error_header: 'Test error' }] },
    }));
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(screen.getByText('DynamicModel Component')).toBeInTheDocument();
  });

  it('triggers idle timeout popup after inactivity', async () => {
    // Mock useSelector to return no loader or errors
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { errors: [], exceptionList: [] },
    }));
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    // Wait for the idle timeout to trigger
    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 150));
    });
    
    expect(screen.getByText('IdleTimeOutModel Component')).toBeInTheDocument();
  });

  it('does not show idle popup when loader is active', async () => {
    // Mock useSelector to return loader state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: true } },
      error: { errors: [], exceptionList: [] },
    }));
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    // Wait for the idle timeout to potentially trigger
    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 150));
    });
    
    expect(screen.queryByText('IdleTimeOutModel Component')).not.toBeInTheDocument();
  });

  it('closes idle popup when handlePopUpClick is called', async () => {
    // Mock useSelector to return no loader or errors
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { errors: [], exceptionList: [] },
    }));
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    // Wait for the idle timeout to trigger
    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 150));
    });
    
    const closeButton = screen.getByText('Close');
    act(() => {
      closeButton.click();
    });
    
    expect(screen.queryByText('IdleTimeOutModel Component')).not.toBeInTheDocument();
  });

  it('triggers Adobe events for errors', () => {
    const mockTriggerAdobeEvent = require('./services/track-events').triggerAdobeEvent;
    
    // Mock useSelector to return error state
    jest.spyOn(require('react-redux'), 'useSelector').mockImplementation(() => ({
      loader: { isFetching: { isFetching: false } },
      error: { 
        errors: ['Test error'], 
        exceptionList: [{ error_header: 'Test exception' }] 
      },
    }));
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(mockTriggerAdobeEvent).toHaveBeenCalledWith('formError');
  });

  it('sets up unload event listener for form abandonment tracking', () => {
    const addEventListenerSpy = jest.spyOn(window, 'addEventListener');
    const mockTriggerAdobeEvent = require('./services/track-events').triggerAdobeEvent;
    
    render(
      <Provider store={store}>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </Provider>
    );
    
    expect(addEventListenerSpy).toHaveBeenCalledWith('unload', expect.any(Function));
    
    // Simulate unload event
    const unloadEvent = new Event('unload');
    window.dispatchEvent(unloadEvent);
    
    expect(mockTriggerAdobeEvent).toHaveBeenCalledWith('formAbandonment', 'BrowserClose');
  });
});
